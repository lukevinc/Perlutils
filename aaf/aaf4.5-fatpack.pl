#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"IO/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL';
  package IO::All;
  $IO::All::VERSION = '0.65';
  use 5.006001;
  use strict;
  use warnings;
  
  require Carp;
  # So one can use Carp::carp "$message" - without the parenthesis.
  sub Carp::carp;
  
  use IO::All::Base -base;
  
  use File::Spec();
  use Symbol();
  use Fcntl;
  use Cwd ();
  
  our @EXPORT = qw(io);
  
  #===============================================================================
  # Object creation and setup methods
  #===============================================================================
  my $autoload = {
      qw(
          touch file
  
          dir_handle dir
          All dir
          all_files dir
          All_Files dir
          all_dirs dir
          All_Dirs dir
          all_links dir
          All_Links dir
          mkdir dir
          mkpath dir
          next dir
  
          stdin stdio
          stdout stdio
          stderr stdio
  
          socket_handle socket
          accept socket
          shutdown socket
  
          readlink link
          symlink link
      )
  };
  
  # XXX - These should die if the given argument exists but is not a
  # link, dbm, etc.
  sub link {my $self = shift; require IO::All::Link; IO::All::Link::link($self, @_) }
  sub dbm {my $self = shift; require IO::All::DBM; IO::All::DBM::dbm($self, @_) }
  sub mldbm {my $self = shift; require IO::All::MLDBM; IO::All::MLDBM::mldbm($self, @_) }
  
  sub autoload {my $self = shift; $autoload }
  
  sub AUTOLOAD {
      my $self = shift;
      my $method = $IO::All::AUTOLOAD;
      $method =~ s/.*:://;
      my $pkg = ref($self) || $self;
      $self->throw(qq{Can't locate object method "$method" via package "$pkg"})
        if $pkg ne $self->package;
      my $class = $self->autoload_class($method);
      my $foo = "$self";
      bless $self, $class;
      $self->$method(@_);
  }
  
  sub autoload_class {
      my $self = shift;
      my $method = shift;
      my $class_id = $self->autoload->{$method} || $method;
      my $ucfirst_class_name = 'IO::All::' . ucfirst($class_id);
      my $ucfirst_class_fn = "IO/All/" . ucfirst($class_id) . ".pm";
      return $ucfirst_class_name if $INC{$ucfirst_class_fn};
      return "IO::All::\U$class_id" if $INC{"IO/All/\U$class_id\E.pm"};
      require IO::All::Temp;
      if (eval "require $ucfirst_class_name; 1") {
          my $class = $ucfirst_class_name;
          my $return = $class->can('new')
          ? $class
          : do { # (OS X hack)
              my $value = $INC{$ucfirst_class_fn};
              delete $INC{$ucfirst_class_fn};
              $INC{"IO/All/\U$class_id\E.pm"} = $value;
              "IO::All::\U$class_id";
          };
          return $return;
      }
      elsif (eval "require IO::All::\U$class_id; 1") {
          return "IO::All::\U$class_id";
      }
      $self->throw("Can't find a class for method '$method'");
  }
  
  sub new {
      my $self = shift;
      my $package = ref($self) || $self;
      my $new = bless Symbol::gensym(), $package;
      $new->package($package);
      $new->_copy_from($self) if ref($self);
      my $name = shift;
      return $name if UNIVERSAL::isa($name, 'IO::All');
      return $new->_init unless defined $name;
      return $new->handle($name)
        if UNIVERSAL::isa($name, 'GLOB') or ref(\ $name) eq 'GLOB';
      # WWW - link is first because a link to a dir returns true for
      # both -l and -d.
      return $new->link($name) if -l $name;
      return $new->file($name) if -f $name;
      return $new->dir($name) if -d $name;
      return $new->$1($name) if $name =~ /^([a-z]{3,8}):/;
      return $new->socket($name) if $name =~ /^[\w\-\.]*:\d{1,5}$/;
      return $new->pipe($name)
        if $name =~ s/^\s*\|\s*// or $name =~ s/\s*\|\s*$//;
      return $new->string if $name eq '$';
      return $new->stdio if $name eq '-';
      return $new->stderr if $name eq '=';
      return $new->temp if $name eq '?';
      $new->name($name);
      $new->_init;
  }
  
  sub _copy_from {
      my $self = shift;
      my $other = shift;
      for (keys(%{*$other})) {
          # XXX Need to audit exclusions here
          next if /^(_handle|io_handle|is_open)$/;
          *$self->{$_} = *$other->{$_};
      }
  }
  
  sub handle {
      my $self = shift;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  # Overloading support
  #===============================================================================
  my $old_warn_handler = $SIG{__WARN__};
  $SIG{__WARN__} = sub {
      if ($_[0] !~ /^Useless use of .+ \(.+\) in void context/) {
          goto &$old_warn_handler if $old_warn_handler;
          warn(@_);
      }
  };
  
  use overload '""' => 'overload_stringify';
  use overload '|' => 'overload_bitwise_or';
  use overload '<<' => 'overload_left_bitshift';
  use overload '>>' => 'overload_right_bitshift';
  use overload '<' => 'overload_less_than';
  use overload '>' => 'overload_greater_than';
  use overload '${}' => 'overload_string_deref';
  use overload '@{}' => 'overload_array_deref';
  use overload '%{}' => 'overload_hash_deref';
  use overload '&{}' => 'overload_code_deref';
  
  sub overload_bitwise_or {my $self = shift; $self->overload_handler(@_, '|') }
  sub overload_left_bitshift {my $self = shift; $self->overload_handler(@_, '<<') }
  sub overload_right_bitshift {my $self = shift; $self->overload_handler(@_, '>>') }
  sub overload_less_than {my $self = shift; $self->overload_handler(@_, '<') }
  sub overload_greater_than {my $self = shift; $self->overload_handler(@_, '>') }
  sub overload_string_deref {my $self = shift; $self->overload_handler(@_, '${}') }
  sub overload_array_deref {my $self = shift; $self->overload_handler(@_, '@{}') }
  sub overload_hash_deref {my $self = shift; $self->overload_handler(@_, '%{}') }
  sub overload_code_deref {my $self = shift; $self->overload_handler(@_, '&{}') }
  
  sub overload_handler {
      my ($self) = @_;
      my $method = $self->get_overload_method(@_);
      $self->$method(@_);
  }
  
  my $op_swap = {
      '>' => '<', '>>' => '<<',
      '<' => '>', '<<' => '>>',
  };
  
  sub overload_table {
      my $self = shift;
      (
          '* > *' => 'overload_any_to_any',
          '* < *' => 'overload_any_from_any',
          '* >> *' => 'overload_any_addto_any',
          '* << *' => 'overload_any_addfrom_any',
  
          '* < scalar' => 'overload_scalar_to_any',
          '* > scalar' => 'overload_any_to_scalar',
          '* << scalar' => 'overload_scalar_addto_any',
          '* >> scalar' => 'overload_any_addto_scalar',
      )
  };
  
  sub get_overload_method {
      my ($self, $arg1, $arg2, $swap, $operator) = @_;
      if ($swap) {
          $operator = $op_swap->{$operator} || $operator;
      }
      my $arg1_type = $self->get_argument_type($arg1);
      my $table1 = { $arg1->overload_table };
  
      if ($operator =~ /\{\}$/) {
          my $key = "$operator $arg1_type";
          return $table1->{$key} || $self->overload_undefined($key);
      }
  
      my $arg2_type = $self->get_argument_type($arg2);
      my @table2 = UNIVERSAL::isa($arg2, "IO::All")
      ? ($arg2->overload_table)
      : ();
      my $table = { %$table1, @table2 };
  
      my @keys = (
          "$arg1_type $operator $arg2_type",
          "* $operator $arg2_type",
      );
      push @keys, "$arg1_type $operator *", "* $operator *"
        unless $arg2_type =~ /^(scalar|array|hash|code|ref)$/;
  
      for (@keys) {
          return $table->{$_}
            if defined $table->{$_};
      }
  
      return $self->overload_undefined($keys[0]);
  }
  
  sub get_argument_type {
      my $self = shift;
      my $argument = shift;
      my $ref = ref($argument);
      return 'scalar' unless $ref;
      return 'code' if $ref eq 'CODE';
      return 'array' if $ref eq 'ARRAY';
      return 'hash' if $ref eq 'HASH';
      return 'ref' unless $argument->isa('IO::All');
      $argument->file
        if defined $argument->pathname and not $argument->type;
      return $argument->type || 'unknown';
  }
  
  sub overload_stringify {
      my $self = shift;
      my $name = $self->pathname;
      return defined($name) ? $name : overload::StrVal($self);
  }
  
  sub overload_undefined {
      my $self = shift;
      require Carp;
      my $key = shift;
      Carp::carp "Undefined behavior for overloaded IO::All operation: '$key'"
        if $^W;
      return 'overload_noop';
  }
  
  sub overload_noop {
      my $self = shift;
      return;
  }
  
  sub overload_any_addfrom_any {
      $_[1]->append($_[2]->all);
      $_[1];
  }
  
  sub overload_any_addto_any {
      $_[2]->append($_[1]->all);
      $_[2];
  }
  
  sub overload_any_from_any {
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]->all);
      $_[1];
  }
  
  sub overload_any_to_any {
      $_[2]->close if $_[2]->is_file and $_[2]->is_open;
      $_[2]->print($_[1]->all);
      $_[2];
  }
  
  sub overload_any_to_scalar {
      $_[2] = $_[1]->all;
  }
  
  sub overload_any_addto_scalar {
      $_[2] .= $_[1]->all;
      $_[2];
  }
  
  sub overload_scalar_addto_any {
      $_[1]->append($_[2]);
      $_[1];
  }
  
  sub overload_scalar_to_any {
      local $\;
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]);
      $_[1];
  }
  
  #===============================================================================
  # Private Accessors
  #===============================================================================
  field 'package';
  field _strict => undef;
  field _layers => [];
  field _handle => undef;
  
  #===============================================================================
  # Public Accessors
  #===============================================================================
  field constructor => undef;
  chain block_size => 1024;
  chain errors => undef;
  field io_handle => undef;
  field is_open => 0;
  chain mode => undef;
  chain name => undef;
  chain perms => undef;
  chain separator => $/;
  field type => '';
  field _partial_spec_class => undef;
  
  sub _spec_class {
     my $self = shift;
  
     my $ret = 'File::Spec';
     if (my $partial = $self->_partial_spec_class(@_)) {
        $ret .= '::' . $partial;
        eval "require $ret";
     }
  
     return $ret
  }
  
  sub pathname {my $self = shift; $self->name(@_) }
  
  #===============================================================================
  # Chainable option methods (write only)
  #===============================================================================
  option 'assert';
  option 'autoclose' => 1;
  option 'backwards';
  option 'chomp';
  option 'confess';
  option 'lock';
  option 'rdonly';
  option 'rdwr';
  option 'strict';
  
  #===============================================================================
  # IO::Handle proxy methods
  #===============================================================================
  proxy 'autoflush';
  proxy 'eof';
  proxy 'fileno';
  proxy 'stat';
  proxy 'tell';
  proxy 'truncate';
  
  #===============================================================================
  # IO::Handle proxy methods that open the handle if needed
  #===============================================================================
  proxy_open print => '>';
  proxy_open printf => '>';
  proxy_open sysread => O_RDONLY;
  proxy_open syswrite => O_CREAT | O_WRONLY;
  proxy_open seek => $^O eq 'MSWin32' ? '<' : '+<';
  proxy_open 'getc';
  
  #===============================================================================
  # Tie Interface
  #===============================================================================
  sub tie {
      my $self = shift;
      tie *$self, $self;
      return $self;
  }
  
  sub TIEHANDLE {
      return $_[0] if ref $_[0];
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->init(@_);
  }
  
  sub READLINE {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub DESTROY {
      my $self = shift;
      no warnings;
      unless ( $] < 5.008 ) {
          untie *$self if tied *$self;
      }
      $self->close if $self->is_open;
  }
  
  sub BINMODE {
      my $self = shift;
      CORE::binmode *$self->io_handle;
  }
  
  {
      no warnings;
      *GETC   = \&getc;
      *PRINT  = \&print;
      *PRINTF = \&printf;
      *READ   = \&read;
      *WRITE  = \&write;
      *SEEK   = \&seek;
      *TELL   = \&getpos;
      *EOF    = \&eof;
      *CLOSE  = \&close;
      *FILENO = \&fileno;
  }
  
  #===============================================================================
  # File::Spec Interface
  #===============================================================================
  sub canonpath {my $self = shift;
     eval { Cwd::abs_path($self->pathname); 0 } ||
        File::Spec->canonpath($self->pathname)
  }
  
  sub catdir {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->dir(File::Spec->catdir(@args));
  }
  sub catfile {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->file(File::Spec->catfile(@args));
  }
  sub join {my $self = shift; $self->catfile(@_) }
  sub curdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->curdir);
  }
  sub devnull {
      my $self = shift;
      $self->constructor->()->file(File::Spec->devnull);
  }
  sub rootdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->rootdir);
  }
  sub tmpdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->tmpdir);
  }
  sub updir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->updir);
  }
  sub case_tolerant {
      my $self = shift;
      File::Spec->case_tolerant;
  }
  sub is_absolute {
      my $self = shift;
      File::Spec->file_name_is_absolute($self->pathname);
  }
  sub path {
      my $self = shift;
      map { $self->constructor->()->dir($_) } File::Spec->path;
  }
  sub splitpath {
      my $self = shift;
      File::Spec->splitpath($self->pathname);
  }
  sub splitdir {
      my $self = shift;
      File::Spec->splitdir($self->pathname);
  }
  sub catpath {
      my $self = shift;
      $self->constructor->(File::Spec->catpath(@_));
  }
  sub abs2rel {
      my $self = shift;
      File::Spec->abs2rel($self->pathname, @_);
  }
  sub rel2abs {
      my $self = shift;
      File::Spec->rel2abs($self->pathname, @_);
  }
  
  #===============================================================================
  # Public IO Action Methods
  #===============================================================================
  sub absolute {
      my $self = shift;
      $self->pathname(File::Spec->rel2abs($self->pathname))
        unless $self->is_absolute;
      $self->is_absolute(1);
      return $self;
  }
  
  sub all {
      my $self = shift;
      $self->assert_open('<');
      local $/;
      my $all = $self->io_handle->getline;
      $self->error_check;
      $self->_autoclose && $self->close;
      return $all;
  }
  
  sub append {
      my $self = shift;
      $self->assert_open('>>');
      $self->print(@_);
  }
  
  sub appendln {
      my $self = shift;
      $self->assert_open('>>');
      $self->println(@_);
  }
  
  sub binary {
      my $self = shift;
      CORE::binmode($self->io_handle) if $self->is_open;
      push @{$self->_layers}, ":raw";
      return $self;
  }
  
  sub binmode {
      my $self = shift;
      my $layer = shift;
      $self->_sane_binmode($layer) if $self->is_open;
      push @{$self->_layers}, $layer;
      return $self;
  }
  
  sub _sane_binmode {
      my ($self, $layer) = @_;
      $layer
      ? CORE::binmode($self->io_handle, $layer)
      : CORE::binmode($self->io_handle);
  }
  
  sub buffer {
      my $self = shift;
      if (not @_) {
          *$self->{buffer} = do {my $x = ''; \ $x}
            unless exists *$self->{buffer};
          return *$self->{buffer};
      }
      my $buffer_ref = ref($_[0]) ? $_[0] : \ $_[0];
      $$buffer_ref = '' unless defined $$buffer_ref;
      *$self->{buffer} = $buffer_ref;
      return $self;
  }
  
  sub clear {
      my $self = shift;
      my $buffer = *$self->{buffer};
      $$buffer = '';
      return $self;
  }
  
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->io_handle(undef);
      $self->mode(undef);
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $message =
        "Can't call empty on an object that is neither file nor directory";
      $self->throw($message);
  }
  
  sub exists {my $self = shift; -e $self->pathname }
  
  sub getline {
      my $self = shift;
      return $self->getline_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my $line;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          $line = $self->io_handle->getline;
          chomp($line) if $self->_chomp and defined $line;
      }
      $self->error_check;
      return $line if defined $line;
      $self->close if $self->_autoclose;
      return undef;
  }
  
  sub getlines {
      my $self = shift;
      return $self->getlines_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my @lines;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          @lines = $self->io_handle->getlines;
          if ($self->_chomp) {
              chomp for @lines;
          }
      }
      $self->error_check;
      return @lines if @lines;
      $self->close if $self->_autoclose;
      return ();
  }
  
  sub is_dir {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Dir') }
  sub is_dbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::DBM') }
  sub is_file {my $self = shift; UNIVERSAL::isa($self, 'IO::All::File') }
  sub is_link {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Link') }
  sub is_mldbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::MLDBM') }
  sub is_socket {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Socket') }
  sub is_stdio {my $self = shift; UNIVERSAL::isa($self, 'IO::All::STDIO') }
  sub is_string {my $self = shift; UNIVERSAL::isa($self, 'IO::All::String') }
  sub is_temp {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Temp') }
  
  sub length {
      my $self = shift;
      length(${$self->buffer});
  }
  
  sub open {
      my $self = shift;
      return $self if $self->is_open;
      $self->is_open(1);
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args;
      unless ($self->is_dir) {
          push @args, $self->mode;
          push @args, $self->perms if defined $self->perms;
      }
      if (defined $self->pathname and not $self->type) {
          $self->file;
          return $self->open(@args);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_binmode;
  }
  
  sub println {
      my $self = shift;
      $self->print(map {/\n\z/ ? ($_) : ($_, "\n")} @_);
  }
  
  sub read {
      my $self = shift;
      $self->assert_open('<');
      my $length = (@_ or $self->type eq 'dir')
      ? $self->io_handle->read(@_)
      : $self->io_handle->read(
          ${$self->buffer},
          $self->block_size,
          $self->length,
      );
      $self->error_check;
      return $length || $self->_autoclose && $self->close && 0;
  }
  
  {
      no warnings;
      *readline = \&getline;
  }
  
  # deprecated
  sub scalar {
      my $self = shift;
      $self->all(@_);
  }
  
  sub slurp {
      my $self = shift;
      my $slurp = $self->all;
      return $slurp unless wantarray;
      my $separator = $self->separator;
      if ($self->_chomp) {
          local $/ = $separator;
          map {chomp; $_} split /(?<=\Q$separator\E)/, $slurp;
      }
      else {
          split /(?<=\Q$separator\E)/, $slurp;
      }
  }
  
  sub utf8 {
      my $self = shift;
      if ($] < 5.008) {
          die "IO::All -utf8 not supported on Perl older than 5.8";
      }
      $self->encoding('UTF-8');
      return $self;
  }
  
  sub _has_utf8 {
      grep { $_ eq ':encoding(UTF-8)' } @{shift->_layers}
  }
  
  sub encoding {
      my $self = shift;
      my $encoding = shift;
      if ($] < 5.008) {
          die "IO::All -encoding not supported on Perl older than 5.8";
      }
      die "No valid encoding string sent" if !$encoding;
      $self->_set_encoding($encoding) if $self->is_open and $encoding;
      push @{$self->_layers}, ":encoding($encoding)";
      return $self;
  }
  
  sub _set_encoding {
      my ($self, $encoding) = @_;
      return CORE::binmode($self->io_handle, ":encoding($encoding)");
  }
  
  sub write {
      my $self = shift;
      $self->assert_open('>');
      my $length = @_
      ? $self->io_handle->write(@_)
      : $self->io_handle->write(${$self->buffer}, $self->length);
      $self->error_check;
      $self->clear unless @_;
      return $length;
  }
  
  #===============================================================================
  # Implementation methods. Subclassable.
  #===============================================================================
  sub throw {
      my $self = shift;
      require Carp;
      ;
      return &{$self->errors}(@_)
        if $self->errors;
      return Carp::confess(@_)
        if $self->_confess;
      return Carp::croak(@_);
  }
  
  #===============================================================================
  # Private instance methods
  #===============================================================================
  sub assert_dirpath {
      my $self = shift;
      my $dir_name = shift;
      return $dir_name if ((! CORE::length($dir_name)) or
        -d $dir_name or
        CORE::mkdir($dir_name, $self->perms || 0755) or
        do {
            require File::Path;
            File::Path::mkpath($dir_name, 0, $self->perms || 0755 );
        } or
        $self->throw("Can't make $dir_name"));
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->file unless $self->type;
      return $self->open(@_);
  }
  
  sub error_check {
      my $self = shift;
      return unless $self->io_handle->can('error');
      return unless $self->io_handle->error;
      $self->throw($!);
  }
  
  sub copy {
      my $self = shift;
      my $copy;
      for (keys %{*$self}) {
          $copy->{$_} = *$self->{$_};
      }
      $copy->{io_handle} = 'defined'
        if defined $copy->{io_handle};
      return $copy;
  }
  
  sub set_binmode {
      my $self = shift;
      $self->_sane_binmode($_) for @{$self->_layers};
      return $self;
  }
  
  #===============================================================================
  # Stat Methods
  #===============================================================================
  BEGIN {
      no strict 'refs';
      my @stat_fields = qw(
          device inode modes nlink uid gid device_id size atime mtime
          ctime blksize blocks
      );
      foreach my $stat_field_idx (0 .. $#stat_fields)
      {
          my $idx = $stat_field_idx;
          my $name = $stat_fields[$idx];
  
          *$name = sub {
              my $self = shift;
              return (stat($self->io_handle || $self->pathname))[$idx];
          };
      }
  }
  
IO_ALL

$fatpacked{"IO/All/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_BASE';
  package IO::All::Base;
  $IO::All::Base::VERSION = '0.65';
  use strict;
  use warnings;
  use Fcntl;
  
  sub import {
      my $class = shift;
      my $flag = $_[0] || '';
      my $package = caller;
      no strict 'refs';
      if ($flag eq '-base') {
          push @{$package . "::ISA"}, $class;
          *{$package . "::$_"} = \&$_
            for qw'field const option chain proxy proxy_open';
      }
      elsif ($flag eq -mixin) {
          mixin_import(scalar(caller(0)), $class, @_);
      }
      else {
          my @flags = @_;
          for my $export (@{$class . '::EXPORT'}) {
              *{$package . "::$export"} = $export eq 'io'
              ? $class->generate_constructor(@flags)
              : \&{$class . "::$export"};
          }
      }
  }
  
  sub generate_constructor {
      my $class = shift;
      my (@flags, %flags, $key);
      for (@_) {
          if (s/^-//) {
              push @flags, $_;
              $flags{$_} = 1;
              $key = $_;
          }
          else {
              $flags{$key} = $_ if $key;
          }
      }
      my $constructor;
      $constructor = sub {
          my $self = $class->new(@_);
          for (@flags) {
              $self->$_($flags{$_});
          }
          $self->constructor($constructor);
          return $self;
      }
  }
  
  sub _init {
      my $self = shift;
      $self->io_handle(undef);
      $self->is_open(0);
      return $self;
  }
  
  #===============================================================================
  # Closure generating functions
  #===============================================================================
  sub option {
      my $package = caller;
      my ($field, $default) = @_;
      $default ||= 0;
      field("_$field", $default);
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            *$self->{"_$field"} = @_ ? shift(@_) : 1;
            return $self;
        };
  }
  
  sub chain {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            if (@_) {
                *$self->{$field} = shift;
                return $self;
            }
            return $default unless exists *$self->{$field};
            return *$self->{$field};
        };
  }
  
  sub field {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            unless (exists *$self->{$field}) {
                *$self->{$field} =
                  ref($default) eq 'ARRAY' ? [] :
                  ref($default) eq 'HASH' ? {} :
                  $default;
            }
            return *$self->{$field} unless @_;
            *$self->{$field} = shift;
        };
  }
  
  sub const {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} = sub { $default };
  }
  
  sub proxy {
      my $package = caller;
      my ($proxy) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      *{"${package}::$proxy"} =
        sub {
            my $self = shift;
            my @return = $self->io_handle->$proxy(@_);
            $self->error_check;
            wantarray ? @return : $return[0];
        };
  }
  
  sub proxy_open {
      my $package = caller;
      my ($proxy, @args) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      my $method = sub {
          my $self = shift;
          $self->assert_open(@args);
          my @return = $self->io_handle->$proxy(@_);
          $self->error_check;
          wantarray ? @return : $return[0];
      };
      *{"$package\::$proxy"} =
      (@args and $args[0] eq '>') ?
      sub {
          my $self = shift;
          $self->$method(@_);
          return $self;
      }
      : $method;
  }
  
  sub mixin_import {
      my $target_class = shift;
      $target_class = caller(0)
        if $target_class eq 'mixin';
      my $mixin_class = shift
        or die "Nothing to mixin";
      eval "require $mixin_class";
      my $pseudo_class = CORE::join '-', $target_class, $mixin_class;
      my %methods = mixin_methods($mixin_class);
      no strict 'refs';
      no warnings;
      @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
      @{"$target_class\::ISA"} = ($pseudo_class);
      for (keys %methods) {
          *{"$pseudo_class\::$_"} = $methods{$_};
      }
  }
  
  sub mixin_methods {
      my $mixin_class = shift;
      no strict 'refs';
      my %methods = all_methods($mixin_class);
      map {
          $methods{$_}
            ? ($_, \ &{"$methods{$_}\::$_"})
            : ($_, \ &{"$mixin_class\::$_"})
      } (keys %methods);
  }
  
  sub all_methods {
      no strict 'refs';
      my $class = shift;
      my %methods = map {
          ($_, $class)
      } grep {
          defined &{"$class\::$_"} and not /^_/
      } keys %{"$class\::"};
      return (%methods);
  }
  
  1;
IO_ALL_BASE

$fatpacked{"IO/All/DBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DBM';
  package IO::All::DBM;
  $IO::All::DBM::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  use Fcntl;
  
  field _dbm_list => [];
  field '_dbm_class';
  field _dbm_extra => [];
  
  sub dbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_dbm_list([@_]);
      return $self;
  }
  
  sub assert_open {
      my $self = shift;
      return $self->tied_file
        if $self->tied_file;
      $self->open;
  }
  
  sub assert_filepath {
      my $self = shift;
      $self->SUPER::assert_filepath(@_);
      if ($self->_rdonly and not -e $self->pathname) {
          my $rdwr = $self->_rdwr;
          $self->assert(0)->rdwr(1)->rdonly(0)->open;
          $self->close;
          $self->assert(1)->rdwr($rdwr)->rdonly(1);
      }
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      return $self->tied_file if $self->tied_file;
      $self->assert_filepath if $self->_assert;
      my $dbm_list = $self->_dbm_list;
      my @dbm_list = @$dbm_list ? @$dbm_list :
        (qw(DB_File GDBM_File NDBM_File ODBM_File SDBM_File));
      my $dbm_class;
      for my $module (@dbm_list) {
          (my $file = "$module.pm") =~ s{::}{/}g;
          if (defined $INC{$file} || eval "eval 'use $module; 1'") {
              $self->_dbm_class($module);
              last;
          }
      }
      $self->throw("No module available for IO::All DBM operation")
        unless defined $self->_dbm_class;
      my $mode = $self->_rdonly ? O_RDONLY : O_RDWR;
      if ($self->_dbm_class eq 'DB_File::Lock') {
          $self->_dbm_class->import;
          my $type = eval '$DB_HASH'; die $@ if $@;
          # XXX Not sure about this warning
          warn "Using DB_File::Lock in IO::All without the rdonly or rdwr method\n"
            if not ($self->_rdwr or $self->_rdonly);
          my $flag = $self->_rdwr ? 'write' : 'read';
          $mode = $self->_rdwr ? O_RDWR : O_RDONLY;
          $self->_dbm_extra([$type, $flag]);
      }
      $mode |= O_CREAT if $mode & O_RDWR;
      $self->mode($mode);
      $self->perms(0666) unless defined $self->perms;
      return $self->tie_dbm;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $hash;
      my $filename = $self->name;
      my $db = tie %$hash, $self->_dbm_class, $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as DBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  sub add_utf8_dbm_filter {
      my $self = shift;
      my $db = shift;
      $db->filter_store_key(sub { utf8::encode($_) });
      $db->filter_store_value(sub { utf8::encode($_) });
      $db->filter_fetch_key(sub { utf8::decode($_) });
      $db->filter_fetch_value(sub { utf8::decode($_) });
  }
  
  1;
IO_ALL_DBM

$fatpacked{"IO/All/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DIR';
  package IO::All::Dir;
  $IO::All::Dir::VERSION = '0.65';
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::Dir;
  
  #===============================================================================
  const type => 'dir';
  option 'sort' => 1;
  chain filter => undef;
  option 'deep';
  field 'chdir_from';
  
  #===============================================================================
  sub dir {
      my $self = shift;
      my $had_prev = blessed($self) && $self->pathname;
  
      bless $self, __PACKAGE__ unless $had_prev;
      if (@_ && @_ > 1 || @_ && $had_prev) {
         $self->name(
             $self->_spec_class->catdir(
                 ($self->pathname ? ($self->pathname) : () ),
                 @_,
             )
         )
      } elsif (@_) {
         $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub dir_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_dirpath($self->pathname)
        if $self->pathname and $self->_assert;
      my $handle = IO::Dir->new;
      $self->io_handle($handle);
      $handle->open($self->pathname)
        or $self->throw($self->open_msg);
      return $self;
  }
  
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      return qq{Can't open directory$name:\n$!};
  }
  
  sub exists { -d shift->pathname }
  
  #===============================================================================
  sub All {
      my $self = shift;
      $self->all(0);
  }
  
  sub all {
      my $self = shift;
      my $depth = @_ ? shift(@_) : $self->_deep ? 0 : 1;
      my $first = not @_;
      my @all;
      while (my $io = $self->next) {
          push @all, $io;
          push(@all, $io->all($depth - 1, 1))
            if $depth != 1 and $io->is_dir;
      }
      @all = grep {&{$self->filter}} @all
        if $self->filter;
      return @all unless $first and $self->_sort;
      return sort {$a->pathname cmp $b->pathname} @all;
  }
  
  sub All_Dirs {
      my $self = shift;
      $self->all_dirs(0);
  }
  
  sub all_dirs {
      my $self = shift;
      grep {$_->is_dir} $self->all(@_);
  }
  
  sub All_Files {
      my $self = shift;
      $self->all_files(0);
  }
  
  sub all_files {
      my $self = shift;
      grep {$_->is_file} $self->all(@_);
  }
  
  sub All_Links {
   my $self = shift;
   $self->all_links(0);
  }
  
  sub all_links {
      my $self = shift;
      grep {$_->is_link} $self->all(@_);
  }
  
  sub chdir {
      my $self = shift;
      require Cwd;
      $self->chdir_from(Cwd::cwd());
      CORE::chdir($self->pathname);
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $dh;
      opendir($dh, $self->pathname) or die;
      while (my $dir = readdir($dh)) {
         return 0 unless $dir =~ /^\.{1,2}$/;
      }
      return 1;
  }
  
  sub mkdir {
      my $self = shift;
      defined($self->perms)
      ? (CORE::mkdir($self->pathname, $self->perms) or die "mkdir failed: $!")
      : (CORE::mkdir($self->pathname) or die "mkdir failed: $!");
      return $self;
  }
  
  sub mkpath {
      my $self = shift;
      require File::Path;
      File::Path::mkpath($self->pathname, @_);
      return $self;
  }
  
  sub file {
      my ($self, @rest) = @_;
  
      return $self->constructor->()->file($self->pathname, @rest)
  }
  
  sub next {
      my $self = shift;
      $self->assert_open;
      my $name = $self->readdir;
      return unless defined $name;
      my $io = $self->constructor->(File::Spec->catfile($self->pathname, $name));
      $io->absolute if $self->is_absolute;
      return $io;
  }
  
  sub readdir {
      my $self = shift;
      $self->assert_open;
      if (wantarray) {
          my @return = grep {
              not /^\.{1,2}$/
          } $self->io_handle->read;
          $self->close;
          return @return;
      }
      my $name = '.';
      while ($name =~ /^\.{1,2}$/) {
          $name = $self->io_handle->read;
          unless (defined $name) {
              $self->close;
              return;
          }
      }
      return $name;
  }
  
  sub rmdir {
      my $self = shift;
      rmdir $self->pathname;
  }
  
  sub rmtree {
      my $self = shift;
      require File::Path;
      File::Path::rmtree($self->pathname, @_);
  }
  
  sub glob {
     my ($self, @rest) = @_;
  
     map {;
        my $ret = $self->constructor->($_);
        $ret->absolute if $self->is_absolute;
        $ret
     } glob $self->_spec_class->catdir( $self->pathname, @rest );
  }
  
  sub DESTROY {
      my $self = shift;
      CORE::chdir($self->chdir_from)
        if $self->chdir_from;
        # $self->SUPER::DESTROY(@_);
  }
  
  #===============================================================================
  sub overload_table {
      (
          '${} dir' => 'overload_as_scalar',
          '@{} dir' => 'overload_as_array',
          '%{} dir' => 'overload_as_hash',
      )
  }
  
  sub overload_as_scalar {
      \ $_[1];
  }
  
  sub overload_as_array {
      [ $_[1]->all ];
  }
  
  sub overload_as_hash {
      +{
          map {
              (my $name = $_->pathname) =~ s/.*[\/\\]//;
              ($name, $_);
          } $_[1]->all
      };
  }
  
  1;
IO_ALL_DIR

$fatpacked{"IO/All/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILE';
  package IO::All::File;
  $IO::All::File::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::File;
  
  #===============================================================================
  const type => 'file';
  field tied_file => undef;
  
  #===============================================================================
  sub file {
      my $self = shift;
      bless $self, __PACKAGE__;
      # should we die here if $self->name is already set and there are args?
      if (@_ && @_ > 1) {
          $self->name( $self->_spec_class->catfile( @_ ) )
      } elsif (@_) {
          $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub file_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_filepath {
      my $self = shift;
      my $name = $self->pathname
        or return;
      my $directory;
      (undef, $directory) = File::Spec->splitpath($self->pathname);
      $self->assert_dirpath($directory);
  }
  
  sub assert_open_backwards {
      my $self = shift;
      return if $self->is_open;
      require File::ReadBackwards;
      my $file_name = $self->pathname;
      my $io_handle = File::ReadBackwards->new($file_name)
        or $self->throw("Can't open $file_name for backwards:\n$!");
      $self->io_handle($io_handle);
      $self->is_open(1);
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub assert_tied_file {
      my $self = shift;
      return $self->tied_file || do {
          eval {require Tie::File};
          $self->throw("Tie::File required for file array operations:\n$@")
            if $@;
          my $array_ref = do { my @array; \@array };
          my $name = $self->pathname;
          my @options = $self->_rdonly ? (mode => O_RDONLY) : ();
          push @options, (recsep => "\n");
          tie @$array_ref, 'Tie::File', $name, @options;
          $self->throw("Can't tie 'Tie::File' to '$name':\n$!")
            unless tied @$array_ref;
          $self->tied_file($array_ref);
      };
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_filepath if $self->_assert;
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args = ($self->mode);
      push @args, $self->perms if defined $self->perms;
      if (defined $self->pathname) {
          $self->io_handle(IO::File->new);
          $self->io_handle->open($self->pathname, @args)
            or $self->throw($self->open_msg);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_lock;
      $self->set_binmode;
  }
  
  sub exists { -f shift->pathname }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open file$name$direction:\n$!};
  }
  
  #===============================================================================
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->unlock;
      $self->io_handle(undef);
      $self->mode(undef);
      if (my $tied_file = $self->tied_file) {
          if (ref($tied_file) eq 'ARRAY') {
              untie @$tied_file;
          }
          else {
              untie %$tied_file;
          }
          $self->tied_file(undef);
          return 1;
      }
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      -z $self->pathname;
  }
  
  sub filepath {
      my $self = shift;
      my ($volume, $path) = $self->splitpath;
      return File::Spec->catpath($volume, $path, '');
  }
  
  sub getline_backwards {
      my $self = shift;
      $self->assert_open_backwards;
      return $self->io_handle->readline;
  }
  
  sub getlines_backwards {
      my $self = shift;
      my @lines;
      while (defined (my $line = $self->getline_backwards)) {
          push @lines, $line;
      }
      return @lines;
  }
  
  sub head {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
  
      LINES:
      while ($lines--) {
          if (defined (my $l = $self->getline)) {
              push @return, $l;
          }
          else {
              last LINES;
          }
      }
  
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub tail {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
      while ($lines--) {
          unshift @return, ($self->getline_backwards or last);
      }
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub touch {
      my $self = shift;
      return $self->SUPER::touch(@_)
        if -e $self->pathname;
      return $self if $self->is_open;
      my $mode = $self->mode;
      $self->mode('>>')->open->close;
      $self->mode($mode);
      return $self;
  }
  
  sub unlink {
      my $self = shift;
      unlink $self->pathname;
  }
  
  #===============================================================================
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          'file > file' => 'overload_file_to_file',
          'file < file' => 'overload_file_from_file',
          '${} file' => 'overload_file_as_scalar',
          '@{} file' => 'overload_file_as_array',
          '%{} file' => 'overload_file_as_dbm',
      )
  }
  
  sub overload_file_to_file {
      require File::Copy;
      File::Copy::copy($_[1]->pathname, $_[2]->pathname);
      $_[2];
  }
  
  sub overload_file_from_file {
      require File::Copy;
      File::Copy::copy($_[2]->pathname, $_[1]->pathname);
      $_[1];
  }
  
  sub overload_file_as_array {
      $_[1]->assert_tied_file;
  }
  
  sub overload_file_as_dbm {
      $_[1]->dbm
        unless $_[1]->isa('IO::All::DBM');
      $_[1]->assert_open;
  }
  
  sub overload_file_as_scalar {
      my $scalar = $_[1]->scalar;
      return \$scalar;
  }
  
  1;
IO_ALL_FILE

$fatpacked{"IO/All/Filesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILESYS';
  package IO::All::Filesys;
  $IO::All::Filesys::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::Base -base;
  use Fcntl qw(:flock);
  
  my %spec_map = (
      unix  => 'Unix',
      win32 => 'Win32',
      vms   => 'VMS',
      mac   => 'Mac',
      os2   => 'OS2',
  );
  sub os {
      my ($self, $type) = @_;
  
      my ($v, $d, $f) = $self->_spec_class->splitpath($self->name);
      my @d = $self->_spec_class->splitdir($d);
  
      $self->_spec_class($spec_map{$type});
  
      $self->name( $self->_spec_class->catfile( @d, $f ) );
  
      return $self
  }
  
  sub exists { my $self = shift; -e $self->name }
  
  sub filename {
      my $self = shift;
      my $filename;
      (undef, undef, $filename) = $self->splitpath;
      return $filename;
  }
  
  sub ext {
     my $self = shift;
  
     return $1 if $self->filename =~ m/\.([^\.]+)$/
  }
  {
      no warnings 'once';
      *extension = \&ext;
  }
  
  sub mimetype {
     require File::MimeInfo;
     return File::MimeInfo::mimetype($_[0]->filename)
  }
  
  sub is_absolute {
      my $self = shift;
      return *$self->{is_absolute} = shift if @_;
      return *$self->{is_absolute}
        if defined *$self->{is_absolute};
      *$self->{is_absolute} = IO::All::is_absolute($self) ? 1 : 0;
  }
  
  sub is_executable { my $self = shift; -x $self->name }
  sub is_readable { my $self = shift; -r $self->name }
  sub is_writable { my $self = shift; -w $self->name }
  {
      no warnings 'once';
      *is_writeable = \&is_writable;
  }
  
  sub pathname {
      my $self = shift;
      return *$self->{pathname} = shift if @_;
      return *$self->{pathname} if defined *$self->{pathname};
      return $self->name;
  }
  
  sub relative {
      my $self = shift;
      $self->pathname(File::Spec->abs2rel($self->pathname))
        if $self->is_absolute;
      $self->is_absolute(0);
      return $self;
  }
  
  sub rename {
      my $self = shift;
      my $new = shift;
      rename($self->name, "$new")
        ? UNIVERSAL::isa($new, 'IO::All')
          ? $new
          : $self->constructor->($new)
        : undef;
  }
  
  sub set_lock {
      my $self = shift;
      return unless $self->_lock;
      my $io_handle = $self->io_handle;
      my $flag = $self->mode =~ /^>>?$/
      ? LOCK_EX
      : LOCK_SH;
      flock $io_handle, $flag;
  }
  
  sub stat {
      my $self = shift;
      return IO::All::stat($self, @_)
        if $self->is_open;
        CORE::stat($self->pathname);
  }
  
  sub touch {
      my $self = shift;
      $self->utime;
  }
  
  sub unlock {
      my $self = shift;
      flock $self->io_handle, LOCK_UN
        if $self->_lock;
  }
  
  sub utime {
      my $self = shift;
      my $atime = shift;
      my $mtime = shift;
      $atime = time unless defined $atime;
      $mtime = $atime unless defined $mtime;
      utime($atime, $mtime, $self->name);
      return $self;
  }
  
  1;
IO_ALL_FILESYS

$fatpacked{"IO/All/Link.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_LINK';
  package IO::All::Link;
  $IO::All::Link::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  
  const type => 'link';
  
  sub link {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      $self->_init;
  }
  
  sub readlink {
      my $self = shift;
      $self->constructor->(CORE::readlink($self->name));
  }
  
  sub symlink {
      my $self = shift;
      my $target = shift;
      $self->assert_filepath if $self->_assert;
      CORE::symlink($target, $self->pathname);
  }
  
  sub AUTOLOAD {
      my $self = shift;
      our $AUTOLOAD;
      (my $method = $AUTOLOAD) =~ s/.*:://;
      my $target = $self->target;
      unless ($target) {
          $self->throw("Can't call $method on symlink");
          return;
      }
      $target->$method(@_);
  }
  
  sub target {
      my $self = shift;
      return *$self->{target} if *$self->{target};
      my %seen;
      my $link = $self;
      my $new;
      while ($new = $link->readlink) {
          my $type = $new->type or return;
          last if $type eq 'file';
          last if $type eq 'dir';
          return unless $type eq 'link';
          return if $seen{$new->name}++;
          $link = $new;
      }
      *$self->{target} = $new;
  }
  
  sub exists { -l shift->pathname }
  
  1;
IO_ALL_LINK

$fatpacked{"IO/All/MLDBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_MLDBM';
  package IO::All::MLDBM;
  $IO::All::MLDBM::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::DBM -base;
  
  field _serializer => 'Data::Dumper';
  
  sub mldbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      my ($serializer) = grep { /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_serializer($serializer) if defined $serializer;
      my @dbm_list = grep { not /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_dbm_list([@dbm_list]);
      return $self;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $filename = $self->name;
      my $dbm_class = $self->_dbm_class;
      my $serializer = $self->_serializer;
      eval "use MLDBM qw($dbm_class $serializer)";
      $self->throw("Can't open '$filename' as MLDBM:\n$@") if $@;
      my $hash;
      my $db = tie %$hash, 'MLDBM', $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as MLDBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  1;
IO_ALL_MLDBM

$fatpacked{"IO/All/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_PIPE';
  package IO::All::Pipe;
  $IO::All::Pipe::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'pipe';
  
  sub pipe {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      require IO::Handle;
      $self->io_handle(IO::Handle->new)
        unless defined $self->io_handle;
      my $command = $self->name;
      $command =~ s/(^\||\|$)//;
      my $mode = shift || $self->mode || '<';
      my $pipe_mode =
        $mode eq '>' ? '|-' :
        $mode eq '<' ? '-|' :
        $self->throw("Invalid usage mode '$mode' for pipe");
      CORE::open($self->io_handle, $pipe_mode, $command);
      $self->set_binmode;
  }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->name
        ? " '" . $self->name . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open pipe$name$direction:\n$!};
  }
  
  1;
IO_ALL_PIPE

$fatpacked{"IO/All/STDIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STDIO';
  package IO::All::STDIO;
  $IO::All::STDIO::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'stdio';
  
  sub stdio {
      my $self = shift;
      bless $self, __PACKAGE__;
      return $self->_init;
  }
  
  sub stdin {
      my $self = shift;
      $self->open('<');
      return $self;
  }
  
  sub stdout {
      my $self = shift;
      $self->open('>');
      return $self;
  }
  
  sub stderr {
      my $self = shift;
      $self->open_stderr;
      return $self;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      my $mode = shift || $self->mode || '<';
      my $fileno = $mode eq '>'
      ? fileno(STDOUT)
      : fileno(STDIN);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen($fileno, $mode);
      $self->set_binmode;
  }
  
  sub open_stderr {
      my $self = shift;
      $self->is_open(1);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen(fileno(STDERR), '>') ? $self : 0;
  }
  
  # XXX Add overload support
  
  1;
IO_ALL_STDIO

$fatpacked{"IO/All/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_SOCKET';
  package IO::All::Socket;
  $IO::All::Socket::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::Socket;
  
  const type => 'socket';
  field _listen => undef;
  option 'fork';
  const domain_default => 'localhost';
  chain domain => undef;
  chain port => undef;
  proxy_open 'recv';
  proxy_open 'send';
  
  sub socket {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub socket_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  sub accept {
      my $self = shift;
      use POSIX ":sys_wait_h";
      sub REAPER {
          while (waitpid(-1, WNOHANG) > 0) {}
          $SIG{CHLD} = \&REAPER;
      }
      local $SIG{CHLD};
      $self->_listen(1);
      $self->assert_open;
      my $server = $self->io_handle;
      my $socket;
      while (1) {
          $socket = $server->accept;
          last unless $self->_fork;
          next unless defined $socket;
          $SIG{CHLD} = \&REAPER;
          my $pid = CORE::fork;
          $self->throw("Unable to fork for IO::All::accept")
            unless defined $pid;
          last unless $pid;
          close $socket;
          undef $socket;
      }
      close $server if $self->_fork;
      my $io = ref($self)->new->socket_handle($socket);
      $io->io_handle($socket);
      $io->is_open(1);
      return $io;
  }
  
  sub shutdown {
      my $self = shift;
      my $how = @_ ? shift : 2;
      my $handle = $self->io_handle;
      $handle->shutdown(2)
        if defined $handle;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      return if $self->is_open;
      $self->is_open(1);
      $self->get_socket_domain_port;
      my @args = $self->_listen
      ? (
          LocalAddr => $self->domain,
          LocalPort => $self->port,
          Proto => 'tcp',
          Listen => 1,
          Reuse => 1,
      )
      : (
          PeerAddr => $self->domain,
          PeerPort => $self->port,
          Proto => 'tcp',
      );
      my $socket = IO::Socket::INET->new(@args)
        or $self->throw("Can't open socket");
      $self->io_handle($socket);
      $self->set_binmode;
  }
  
  sub get_socket_domain_port {
      my $self = shift;
      my ($domain, $port);
      ($domain, $port) = split /:/, $self->name
        if defined $self->name;
      $self->domain($domain) unless defined $self->domain;
      $self->domain($self->domain_default) unless $self->domain;
      $self->port($port) unless defined $self->port;
      return $self;
  }
  
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          '&{} socket' => 'overload_socket_as_code',
      )
  }
  
  sub overload_socket_as_code {
      my $self = shift;
      sub {
          my $coderef = shift;
          while ($self->is_open) {
              $_ = $self->getline;
              &$coderef($self);
          }
      }
  }
  
  sub overload_any_from_any {
      my $self = shift;
      $self->SUPER::overload_any_from_any(@_);
      $self->close;
  }
  
  sub overload_any_to_any {
      my $self = shift;
      $self->SUPER::overload_any_to_any(@_);
      $self->close;
  }
  
  1;
IO_ALL_SOCKET

$fatpacked{"IO/All/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STRING';
  package IO::All::String;
  $IO::All::String::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  
  const type => 'string';
  
  
  sub string_ref {
     my ($self, $ref) = @_;
  
     no strict 'refs';
     *$self->{ref} = $ref if exists $_[1];
  
     return *$self->{ref}
  }
  
  sub string {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_init;
  }
  
  sub open {
      my $self = shift;
      my $str = '';
      my $ref = \$str;
      $self->string_ref($ref);
      open my $fh, '+<', $ref;
      $self->io_handle($fh);
      $self->set_binmode;
      $self->is_open(1);
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::String - String IO Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2005. Brian Ingerson. All rights reserved.
  
  Copyright (c) 2006-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_STRING

$fatpacked{"IO/All/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_TEMP';
  package IO::All::Temp;
  $IO::All::Temp::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  
  sub temp {
      my $self = shift;
      bless $self, __PACKAGE__;
      my $temp_file = IO::File::new_tmpfile()
        or $self->throw("Can't create temporary file");
      $self->io_handle($temp_file);
      $self->error_check;
      $self->autoclose(0);
      $self->is_open(1);
      return $self;
  }
  
  1;
IO_ALL_TEMP

$fatpacked{"x86_64-linux/Term/ReadLine/Gnu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_TERM_READLINE_GNU';
  #
  #	Gnu.pm --- The GNU Readline/History Library wrapper module
  #
  #	$Id: Gnu.pm 468 2014-03-23 11:56:58Z hayashi $
  #
  #	Copyright (c) 2014 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  #
  #	Some of documentation strings in this file are cited from the
  #	GNU Readline/History Library Manual.
  
  package Term::ReadLine::Gnu;
  
  =head1 NAME
  
  Term::ReadLine::Gnu - Perl extension for the GNU Readline/History Library
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;	# Do not "use Term::ReadLine::Gnu;"
    $term = new Term::ReadLine 'ProgramName';
    while ( defined ($_ = $term->readline('prompt>')) ) {
      ...
    }
  
  =head1 DESCRIPTION
  
  =head2 Overview
  
  This is an implementation of
  L<Term::ReadLine|http://search.cpan.org/dist/Term-ReadLine/> using
  L<the GNU ReadlineE<sol>History
  Library|http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>.
  
  For basic functions object oriented interface is provided. These are
  described in the section L<"Standard Methods"|"Standard Methods"> and
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">.
  
  This package also has the interface with the almost all functions and
  variables which are documented in the GNU Readline/History Library
  Manual.  They are documented in the section
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">
  and
  L<"C<Term::ReadLine::Gnu> Variables"|"C<Term::ReadLine::Gnu>
  Variables"> briefly.  For more detail of the GNU Readline/History
  Library, see L<GNU Readline Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/readline.html> and
  L<GNU History Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/history.html>.
  
  The sample programs under F<eg/> directory and test programs under
  F<t/> directory in L<the C<Term::ReadLine::Gnu> distribution|http://search.cpan.org/dist/Term-ReadLine-Gnu/> include
  many example of this module.
  
  =head2 Standard Methods
  
  These methods are standard methods defined by
  L<Term::ReadLine|http://search.cpan.org/dist/Term-ReadLine/>.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  # use version 1.22 for perl 5.7.x, or 1.09 for older Perl
  use 5.008; use 5.8.0;
  
  # This module can't be loaded directly.
  BEGIN {
      if (not defined $Term::ReadLine::VERSION) {
          croak <<END;
  It is invalid to load Term::ReadLine::Gnu directly.  Please consult
  the Term::ReadLine documentation for more information.
  END
      }
  }
  
  {
      use Exporter ();
      use DynaLoader;
      use vars qw($VERSION @ISA @EXPORT_OK);
  
      $VERSION = '1.24';		# update Gnu::XS::VERSION also.
  
      # Term::ReadLine::Gnu::AU makes a function in
      # `Term::ReadLine::Gnu::XS' as a method.
      # The namespace of Term::ReadLine::Gnu::AU is searched before ones
      # of other classes
      @ISA = qw(Term::ReadLine::Gnu::AU Term::ReadLine::Stub
  	      Exporter DynaLoader);
  
      @EXPORT_OK = qw(RL_PROMPT_START_IGNORE RL_PROMPT_END_IGNORE
  		    NO_MATCH SINGLE_MATCH MULT_MATCH
  		    ISFUNC ISKMAP ISMACR
  		    UNDO_DELETE UNDO_INSERT UNDO_BEGIN UNDO_END
  		    RL_STATE_NONE RL_STATE_INITIALIZING
  		    RL_STATE_INITIALIZED RL_STATE_TERMPREPPED
  		    RL_STATE_READCMD RL_STATE_METANEXT
  		    RL_STATE_DISPATCHING RL_STATE_MOREINPUT
  		    RL_STATE_ISEARCH RL_STATE_NSEARCH
  		    RL_STATE_SEARCH RL_STATE_NUMERICARG
  		    RL_STATE_MACROINPUT RL_STATE_MACRODEF
  		    RL_STATE_OVERWRITE RL_STATE_COMPLETING
  		    RL_STATE_SIGHANDLER RL_STATE_UNDOING
  		    RL_STATE_INPUTPENDING RL_STATE_TTYCSAVED
  		    RL_STATE_CALLBACK RL_STATE_VIMOTION
  		    RL_STATE_MULTIKEY RL_STATE_VICMDONCE
  		    RL_STATE_DONE);
  
      bootstrap Term::ReadLine::Gnu $VERSION; # DynaLoader
  }
  require Term::ReadLine::Gnu::XS;
  
  #	Global Variables
  
  use vars qw(%Attribs %Features);
  
  # Each variable in the GNU Readline Library is tied to an entry of
  # this hash (%Attribs).  By accessing the hash entry, you can read
  # and/or write the variable in the GNU Readline Library.  See the
  # package definition of Term::ReadLine::Gnu::Var and following code
  # for more details.
  
  # Normal (non-tied) entries
  %Attribs  = (
  	     MinLength => 1,
  	     do_expand => 0,
  	     completion_word => [],
  	     term_set => ['', '', '', ''],
  	    );
  %Features = (
  	     appname => 1, minline => 1, autohistory => 1,
  	     getHistory => 1, setHistory => 1, addHistory => 1,
  	     readHistory => 1, writeHistory => 1,
  	     preput => 1, attribs => 1, newTTY => 1,
  	     tkRunning => Term::ReadLine::Stub->Features->{'tkRunning'},
  	     ornaments => Term::ReadLine::Stub->Features->{'ornaments'},
  	     stiflehistory => 1,
  	    );
  
  # keep rl_readline_version value for efficiency
  my $readline_version;
  
  #
  #	GNU Readline/History Library constant definition
  #	These are included in @EXPORT_OK.
  
  # I can define these variables in XS code to use the value defined in
  # readline.h, etc.  But it needs some calling convention change and
  # will cause compatiblity problem. I hope the definition of these
  # constant value will not be changed.
  
  # for non-printing characters in prompt string
  sub RL_PROMPT_START_IGNORE	{ "\001"; }
  sub RL_PROMPT_END_IGNORE	{ "\002"; }
  
  # for rl_filename_quoting_function
  sub NO_MATCH	 { 0; }
  sub SINGLE_MATCH { 1; }
  sub MULT_MATCH   { 2; }
  
  # for rl_generic_bind, rl_function_of_keyseq
  sub ISFUNC	{ 0; }
  sub ISKMAP	{ 1; }
  sub ISMACR	{ 2; }
  
  # for rl_add_undo
  sub UNDO_DELETE	{ 0; }
  sub UNDO_INSERT	{ 1; }
  sub UNDO_BEGIN	{ 2; }
  sub UNDO_END	{ 3; }
  
  # for rl_readline_state
  sub RL_STATE_NONE		{ 0x00000; } # no state; before first call
  sub RL_STATE_INITIALIZING	{ 0x00001; } # initializing
  sub RL_STATE_INITIALIZED	{ 0x00002; } # initialization done
  sub RL_STATE_TERMPREPPED	{ 0x00004; } # terminal is prepped
  sub RL_STATE_READCMD		{ 0x00008; } # reading a command key
  sub RL_STATE_METANEXT		{ 0x00010; } # reading input after ESC
  sub RL_STATE_DISPATCHING	{ 0x00020; } # dispatching to a command
  sub RL_STATE_MOREINPUT		{ 0x00040; } # reading more input in a command function
  sub RL_STATE_ISEARCH		{ 0x00080; } # doing incremental search
  sub RL_STATE_NSEARCH		{ 0x00100; } # doing non-inc search
  sub RL_STATE_SEARCH		{ 0x00200; } # doing a history search
  sub RL_STATE_NUMERICARG		{ 0x00400; } # reading numeric argument
  sub RL_STATE_MACROINPUT		{ 0x00800; } # getting input from a macro
  sub RL_STATE_MACRODEF		{ 0x01000; } # defining keyboard macro
  sub RL_STATE_OVERWRITE		{ 0x02000; } # overwrite mode
  sub RL_STATE_COMPLETING		{ 0x04000; } # doing completion
  sub RL_STATE_SIGHANDLER		{ 0x08000; } # in readline sighandler
  sub RL_STATE_UNDOING		{ 0x10000; } # doing an undo
  # The following RL_STATE_* are defined since TRL 6.0
  sub RL_STATE_INPUTPENDING	{ 0x020000; } #	rl_execute_next called
  sub RL_STATE_TTYCSAVED		{ 0x040000; } #	tty special chars saved
  sub RL_STATE_CALLBACK		{ 0x080000; } #	using the callback interface
  sub RL_STATE_VIMOTION		{ 0x100000; } #	reading vi motion arg
  sub RL_STATE_MULTIKEY		{ 0x200000; } #	reading multiple-key command
  sub RL_STATE_VICMDONCE		{ 0x400000; } #	entered vi command mode at least once
  # The following RL_STATE_* is defined since TRL 6.1
  sub RL_STATE_REDISPLAYING	{ 0x800000; } #	updating terminal display
  # The value was changed since TRL 6.0 and 6.1
  # done; accepted line
  sub RL_STATE_DONE { $readline_version < 0x0600 ? 0x80000 : 
  			($readline_version < 0x0601 ? 0x800000 : 0x1000000); }
  
  #
  #	Methods Definition
  #
  
  =over 4
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. If you have
  installed this package,  possible value is C<Term::ReadLine::Gnu>.
  
  =cut
  
  sub ReadLine { 'Term::ReadLine::Gnu'; }
  
  =item C<new(NAME,[IN[,OUT]])>
  
  returns the handle for subsequent calls to following functions.
  Argument is the name of the application.  Optionally can be followed
  by two arguments for C<IN> and C<OUT> file handles. These arguments
  should be globs.
  
  =cut
  
  # The origin of this function is Term::ReadLine::Perl.pm by Ilya Zakharevich.
  sub new {
      my $this = shift;		# Package
      my $class = ref($this) || $this;
  
      my $name = shift;
  
      my $self = \%Attribs;
      bless $self, $class;
  
      # set rl_readline_name before .inputrc is read in rl_initialize()
      $Attribs{readline_name} = $name;
  
      # some version of Perl cause segmentation fault, if XS module
      # calls setenv() before the 1st assignment to $ENV{}.
      $ENV{_TRL_DUMMY} = '';
  
      # initialize the GNU Readline Library and termcap library
      $self->initialize();
  
      # enable ornaments to be compatible with perl5.004_05(?)
      $self->ornaments(1) unless ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/);
  
      if (!@_) {
  	my ($IN,$OUT) = $self->findConsole();
  	open(IN,"<$IN")   || croak "Cannot open $IN for read";
  	open(OUT,">$OUT") || croak "Cannot open $OUT for write";
  	# borrowed from Term/ReadLine.pm
  	my $sel = select(OUT);
  	$| = 1;				# for DB::OUT
  	select($sel);
  	$Attribs{instream} = \*IN;
  	$Attribs{outstream} = \*OUT;
      } else {
  	$Attribs{instream} = shift;
  	$Attribs{outstream} = shift;
      }
      $readline_version = $Attribs{readline_version};
  
      $self;
  }
  
  sub DESTROY {}
  
  =item C<readline(PROMPT[,PREPUT])>
  
  gets an input line, with actual C<GNU Readline> support.  Trailing
  newline is removed.  Returns C<undef> on C<EOF>.  C<PREPUT> is an
  optional argument meaning the initial value of input.
  
  The optional argument C<PREPUT> is granted only if the value C<preput>
  is in C<Features>.
  
  C<PROMPT> may include some escape sequences.  Use
  C<RL_PROMPT_START_IGNORE> to begin a sequence of non-printing
  characters, and C<RL_PROMPT_END_IGNORE> to end of such a sequence.
  
  =cut
  
  # to peacify -w
  $Term::ReadLine::registered = $Term::ReadLine::registered;
  
  sub readline {			# should be ReadLine
      my $self = shift;
      my ($prompt, $preput) = @_;
  
      # contributed fix for Perl debugger
      # make sure the outstream fd inside the readline library is
      # in sync (see http://bugs.debian.org/236018)
      # This is not a real fix but left for system where this fix works.
      # Here is the real fix for perl5db.pl.
      # https://rt.perl.org/Public/Bug/Display.html?id=121456
      $Attribs{outstream} = $Attribs{outstream};
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      # `completion_function' support for compatibility with
      # Term:ReadLine::Perl.  Prefer $completion_entry_function, since a
      # program which uses $completion_entry_function should know
      # Term::ReadLine::Gnu and have better completion function using
      # the variable.
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      # TkRunning support
      if (not $Term::ReadLine::registered and $Term::ReadLine::toloop
  	and defined &Tk::DoOneEvent) {
  	$self->register_Tk;
  	$Attribs{getc_function} = $Attribs{Tk_getc};
      }
  
      # call readline()
      my $line;
      if (defined $preput) {
  	my $saved_startup_hook = $Attribs{startup_hook};
  	$Attribs{startup_hook} = sub {
  	    $self->rl_insert_text($preput);
  	    &$saved_startup_hook
  		if defined $saved_startup_hook;
  	};
  	$line = $self->rl_readline($prompt);
  	$Attribs{startup_hook} = $saved_startup_hook;
      } else {
  	$line = $self->rl_readline($prompt);
      }
      return undef unless defined $line;
  
      # from ReadLine.pm: convert to the internal representation from UTF-8
      # see 'perldoc perlvar'
      if ((${^UNICODE} & 1 || defined ${^ENCODING}) &&
  	utf8::valid($line)) {
  	#utf8::upgrade($line);
  	utf8::decode($line);
      }
  
      # history expansion
      if ($Attribs{do_expand}) {
  	my $result;
  	($result, $line) = $self->history_expand($line);
  	my $outstream = $Attribs{outstream};
  	print $outstream "$line\n" if ($result);
  
  	# return without adding line into history
  	if ($result < 0 || $result == 2) {
  	    return '';		# don't return `undef' which means EOF.
  	}
      }
  
      # add to history buffer
      $self->add_history($line)
  	if (defined $self->{MinLength} && $self->{MinLength} > 0
  	    && length($line) >= $self->{MinLength});
  
      return $line;
  }
  
  =item C<AddHistory(LINE1, LINE2, ...)>
  
  adds the lines to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =cut
  
  use vars '*addhistory';
  *addhistory = \&AddHistory;	# for backward compatibility
  
  sub AddHistory {
      my $self = shift;
      foreach (@_) {
  	$self->add_history($_);
      }
  }
  
  =item C<IN>, C<OUT>
  
  return the file handles for input and output or C<undef> if
  C<readline> input and output cannot be used for Perl.
  
  =cut
  
  sub IN  { $Attribs{instream}; }
  sub OUT { $Attribs{outstream}; }
  
  =item C<MinLine([MAX])>
  
  If argument C<MAX> is specified, it is an advice on minimal size of
  line to be included into history.  C<undef> means do not include
  anything into history.  Returns the old value.
  
  =cut
  
  sub MinLine {
      my $self = shift;
      my $old_minlength = $self->{MinLength};
      $self->{MinLength} = shift;
      $old_minlength;
  }
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>$out">.
  
  =cut
  
  # findConsole is defined in ReadLine.pm.
  
  =item C<Attribs>
  
  returns a reference to a hash which describes internal configuration
  (variables) of the package.  Names of keys in this hash conform to
  standard conventions with the leading C<rl_> stripped.
  
  See section "Variables" for supported variables.
  
  =cut
  
  sub Attribs { \%Attribs; }
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addHistory> if C<AddHistory> method is not dummy. 
  C<preput> means the second argument to C<readline> method is processed.
  C<getHistory> and C<setHistory> denote that the corresponding methods are 
  present. C<tkRunning> denotes that a Tk application may run while ReadLine
  is getting input.
  
  =cut
  
  sub Features { \%Features; }
  
  =item C<tkRunning>
  
  makes Tk event loop run when waiting for user input (i.e., during
  C<readline> method).
  
  =cut
  
  # tkRunning is defined in ReadLine.pm.
  
  =item C<ornaments>
  
  makes the command line stand out by using termcap data.  The argument
  to C<ornaments> should be 0, 1, or a string of a form
  C<"aa,bb,cc,dd">.  Four components of this string should be names of
  I<terminal capacities>, first two will be issued to make the prompt
  standout, last two to make the input line standout.
  
  =cut
  
  sub ornaments {
      my $self = shift;
      return Term::ReadLine::Gnu::XS::ornaments(@_);
  }
  
  =item C<newTTY>
  
  takes two arguments which are input filehandle and output filehandle.
  Switches to use these filehandles.
  
  =cut
  
  # used by a program who changes input/output stream.
  # perldb5.pl is an example.
  sub newTTY {
      my ($self, $in, $out) = @_;
      $Attribs{instream}  = $in;
      $Attribs{outstream} = $out;
      my $sel = select($out);
      $| = 1;			# for DB::OUT
      select($sel);
  }
  
  =back
  
  =cut
  
  # documented later
  sub CallbackHandlerInstall {
      my $self = shift;
      my ($prompt, $lhandler) = @_;
  
      $Attribs{_callback_handler} = $lhandler;
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      $self->rl_callback_handler_install($prompt,
  				       \&Term::ReadLine::Gnu::XS::_ch_wrapper);
  }
  
  
  #
  #	Additional Supported Methods
  #
  
  # Documentation is after '__END__' for efficiency.
  
  # for backward compatibility
  use vars qw(*AddDefun *BindKey *UnbindKey *ParseAndBind *StifleHistory);
  *AddDefun = \&add_defun;
  *BindKey = \&bind_key;
  *UnbindKey = \&unbind_key;
  *ParseAndBind = \&parse_and_bind;
  *StifleHistory = \&stifle_history;
  
  sub SetHistory {
      my $self = shift;
      $self->clear_history();
      $self->AddHistory(@_);
  }
  
  sub GetHistory {
      my $self = shift;
      $self->history_list();
  }
  
  sub ReadHistory {
      my $self = shift;
      ! $self->read_history_range(@_);
  }
  
  sub WriteHistory {
      my $self = shift;
      ! $self->write_history(@_);
  }
  
  #
  #	Access Routines for GNU Readline/History Library Variables
  #
  package Term::ReadLine::Gnu::Var;
  use Carp;
  use strict;
  use vars qw(%_rl_vars);
  
  %_rl_vars
      = (
         rl_line_buffer				=> ['S', 0],
         rl_prompt				=> ['S', 1],
         rl_library_version			=> ['S', 2],
         rl_terminal_name				=> ['S', 3],
         rl_readline_name				=> ['S', 4],
         rl_basic_word_break_characters		=> ['S', 5],
         rl_basic_quote_characters		=> ['S', 6],
         rl_completer_word_break_characters	=> ['S', 7],
         rl_completer_quote_characters		=> ['S', 8],
         rl_filename_quote_characters		=> ['S', 9],
         rl_special_prefixes			=> ['S', 10],
         history_no_expand_chars			=> ['S', 11],
         history_search_delimiter_chars		=> ['S', 12],
         rl_executing_macro			=> ['S', 13], # GRL 4.2
         history_word_delimiters			=> ['S', 14], # GRL 4.2
         rl_display_prompt			=> ['S', 15], # GRL 6.0
         rl_executing_keyseq			=> ['S', 16], # GRL 6.3
  
         rl_point					=> ['I', 0],
         rl_end					=> ['I', 1],
         rl_mark					=> ['I', 2],
         rl_done					=> ['I', 3],
         rl_pending_input				=> ['I', 4],
         rl_completion_query_items		=> ['I', 5],
         rl_completion_append_character		=> ['C', 6],
         rl_ignore_completion_duplicates		=> ['I', 7],
         rl_filename_completion_desired		=> ['I', 8],
         rl_filename_quoting_desired		=> ['I', 9],
         rl_inhibit_completion			=> ['I', 10],
         history_base				=> ['I', 11],
         history_length				=> ['I', 12],
         history_max_entries			=> ['I', 13],
         max_input_history			=> ['I', 13], # before GRL 4.2
         history_write_timestamps			=> ['I', 14], # GRL 5.0
         history_expansion_char			=> ['C', 15],
         history_subst_char			=> ['C', 16],
         history_comment_char			=> ['C', 17],
         history_quotes_inhibit_expansion		=> ['I', 18],
         rl_erase_empty_line			=> ['I', 19], # GRL 4.0
         rl_catch_signals				=> ['I', 20], # GRL 4.0
         rl_catch_sigwinch			=> ['I', 21], # GRL 4.0
         rl_already_prompted			=> ['I', 22], # GRL 4.1
         rl_num_chars_to_read			=> ['I', 23], # GRL 4.1
         rl_dispatching				=> ['I', 24], # GRL 4.2
         rl_gnu_readline_p			=> ['I', 25], # GRL 4.1
         rl_readline_state			=> ['I', 26], # GRL 4.2
         rl_explicit_arg				=> ['I', 27], # GRL 4.2
         rl_numeric_arg				=> ['I', 28], # GRL 4.2
         rl_editing_mode				=> ['I', 29], # GRL 4.2
         rl_attempted_completion_over		=> ['I', 30], # GRL 4.2
         rl_completion_type			=> ['I', 31], # GRL 4.2
         rl_readline_version			=> ['I', 32], # GRL 4.2a
         rl_completion_suppress_append		=> ['I', 33], # GRL 4.3
         rl_completion_quote_character		=> ['C', 34], # GRL 5.0
         rl_completion_suppress_quote		=> ['I', 35], # GRL 5.0
         rl_completion_found_quote		=> ['I', 36], # GRL 5.0
         rl_completion_mark_symlink_dirs		=> ['I', 37], # GRL 4.3
         rl_prefer_env_winsize			=> ['I', 38], # GRL 5.1
         rl_sort_completion_matches		=> ['I', 39], # GRL 6.0
         rl_completion_invoking_key		=> ['C', 40], # GRL 6.0
         rl_executing_key				=> ['I', 41], # GRL 6.3
         rl_key_sequence_length			=> ['I', 42], # GRL 6.3
         rl_change_environment			=> ['I', 43], # GRL 6.3
  
         rl_startup_hook				=> ['F', 0],
         rl_event_hook				=> ['F', 1],
         rl_getc_function				=> ['F', 2],
         rl_redisplay_function			=> ['F', 3],
         rl_completion_entry_function		=> ['F', 4],
         rl_attempted_completion_function		=> ['F', 5],
         rl_filename_quoting_function		=> ['F', 6],
         rl_filename_dequoting_function		=> ['F', 7],
         rl_char_is_quoted_p			=> ['F', 8],
         rl_ignore_some_completions_function	=> ['F', 9],
         rl_directory_completion_hook		=> ['F', 10],
         history_inhibit_expansion_function	=> ['F', 11],
         rl_pre_input_hook			=> ['F', 12], # GRL 4.0
         rl_completion_display_matches_hook	=> ['F', 13], # GRL 4.0
         rl_completion_word_break_hook		=> ['F', 14], # GRL 5.0
         rl_prep_term_function			=> ['F', 15], # GRL 4.2
         rl_deprep_term_function			=> ['F', 16], # GRL 4.2
         rl_directory_rewrite_hook		=> ['F', 17], # GRL 4.2
         rl_filename_rewrite_hook			=> ['F', 18], # GRL 6.1
         rl_signal_event_hook			=> ['F', 19], # GRL 6.3
         rl_input_available_hook			=> ['F', 20], # GRL 6.3
         rl_filename_stat_hook			=> ['F', 21], # GRL 6.3
  
         rl_instream				=> ['IO', 0],
         rl_outstream				=> ['IO', 1],
  
         rl_executing_keymap			=> ['K', 0],
         rl_binding_keymap			=> ['K', 1],
  
         rl_last_func                             => ['LF', 0],
        );
  
  sub TIESCALAR {
      my $class = shift;
      my $name = shift;
      return bless \$name, $class;
  }
  
  sub FETCH {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::FETCH: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	return _rl_fetch_str($id);
      } elsif ($type eq 'I') {
  	return _rl_fetch_int($id);
      } elsif ($type eq 'C') {
  	return chr(_rl_fetch_int($id));
      } elsif ($type eq 'F') {
  	return _rl_fetch_function($id);
      } elsif ($type eq 'IO') {
  	return _rl_fetch_iostream($id);
      } elsif ($type eq 'K') {
  	return _rl_fetch_keymap($id);
      } elsif ($type eq 'LF') {
          return _rl_fetch_last_func();
      } else {
  	carp "Term::ReadLine::Gnu::Var::FETCH: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  sub STORE {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::STORE: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my $value = shift;
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	if ($name eq 'rl_line_buffer') {
  	    return _rl_store_rl_line_buffer($value);
  	} else {
  	    return _rl_store_str($value, $id);
  	}
      } elsif ($type eq 'I') {
  	return _rl_store_int($value, $id);
      } elsif ($type eq 'C') {
  	return chr(_rl_store_int(ord($value), $id));
      } elsif ($type eq 'F') {
  	return _rl_store_function($value, $id);
      } elsif ($type eq 'IO') {
  	# pop stdio layer pushed by PerlIO_findFILE().
  	# https://rt.cpan.org/Ticket/Display.html?id=59832
  	my $FH = _rl_store_iostream($value, $id);
  	my @layers = PerlIO::get_layers($FH);
  	#warn "$id<", join(':', @layers), "\n";
  	binmode($FH, ":pop") if @layers > 1;
  	#@layers = PerlIO::get_layers($FH); warn "$id>", join(':', @layers), "\n";
  	return $FH;
      } elsif ($type eq 'K' || $type eq 'LF') {
  	carp "Term::ReadLine::Gnu::Var::STORE: read only variable `$name'\n";
  	return undef;
      } else {
  	carp "Term::ReadLine::Gnu::Var::STORE: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  package Term::ReadLine::Gnu;
  use Carp;
  use strict;
  
  #
  #	set value of %Attribs
  #
  
  #	Tie all Readline/History variables
  foreach (keys %Term::ReadLine::Gnu::Var::_rl_vars) {
      my $name;
      ($name = $_) =~ s/^rl_//;	# strip leading `rl_'
      tie $Attribs{$name},  'Term::ReadLine::Gnu::Var', $_;
  }
  
  #	add reference to some functions
  {
      my ($name, $fname);
      no strict 'refs';		# allow symbolic reference
      map {
  	($name = $_) =~ s/^rl_//; # strip leading `rl_'
  	$fname = 'Term::ReadLine::Gnu::XS::' . $_;
  	$Attribs{$name} = \&$fname; # symbolic reference
      } qw(rl_getc
  	 rl_redisplay
  	 rl_callback_read_char
  	 rl_display_match_list
  	 rl_filename_completion_function
  	 rl_username_completion_function
  	 list_completion_function
           _trp_completion_function);
      # auto-split subroutine cannot be processed in the map loop above
      use strict 'refs';
      $Attribs{shadow_redisplay} = \&Term::ReadLine::Gnu::XS::shadow_redisplay;
      $Attribs{Tk_getc} = \&Term::ReadLine::Gnu::XS::Tk_getc;
      $Attribs{list_completion_function} = \&Term::ReadLine::Gnu::XS::list_completion_function;
  }
  
  package Term::ReadLine::Gnu::AU;
  use Carp;
  no strict qw(refs vars);
  
  sub AUTOLOAD {
      { $AUTOLOAD =~ s/.*:://; }	# preserve match data
      my $name;
      if (exists $Term::ReadLine::Gnu::XS::{"rl_$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::rl_$AUTOLOAD";
      } elsif (exists $Term::ReadLine::Gnu::XS::{"$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::$AUTOLOAD";
      } else {
  	croak "Cannot do `$AUTOLOAD' in Term::ReadLine::Gnu";
      }
      no warnings 'redefine';	# Why is this line necessary ?
      *$AUTOLOAD = sub { shift; &$name(@_); };
      goto &$AUTOLOAD;
  }
  1;
  __END__
  
  
  =head2 C<Term::ReadLine::Gnu> Functions
  
  All these GNU Readline/History Library functions are callable via
  method interface and have names which conform to standard conventions
  with the leading C<rl_> stripped.
  
  Almost methods have lower level functions in
  C<Term::ReadLine::Gnu::XS> package.  To use them full qualified name
  is required.  Using method interface is preferred.
  
  =over 4
  
  =item Readline Convenience Functions
  
  =over 4
  
  =item Naming Function
  
  =over 4
  
  =item C<add_defun(NAME, FUNC [,KEY=-1])>
  
  Add name to the Perl function C<FUNC>.  If optional argument C<KEY> is
  specified, bind it to the C<FUNC>.  Returns reference to
  C<FunctionPtr>.
  
    Example:
  	# name name `reverse-line' to a function reverse_line(),
  	# and bind it to "\C-t"
  	$term->add_defun('reverse-line', \&reverse_line, ord "\ct");
  
  =back
  
  =item Selecting a Keymap
  
  =over 4
  
  =item C<make_bare_keymap>
  
  	Keymap	rl_make_bare_keymap()
  
  =item C<copy_keymap(MAP)>
  
  	Keymap	rl_copy_keymap(Keymap|str map)
  
  =item C<make_keymap>
  
  	Keymap	rl_make_keymap()
  
  =item C<discard_keymap(MAP)>
  
  	Keymap	rl_discard_keymap(Keymap|str map)
  
  =item C<free_keymap(MAP)>
  
  	void	rl_free_keymap(Keymap|str map)
  
  =item C<get_keymap>
  
  	Keymap	rl_get_keymap()
  
  =item C<set_keymap(MAP)>
  
  	Keymap	rl_set_keymap(Keymap|str map)
  
  =item C<get_keymap_by_name(NAME)>
  
  	Keymap	rl_get_keymap_by_name(str name)
  
  =item C<get_keymap_name(MAP)>
  
  	str	rl_get_keymap_name(Keymap map)
  
  =back
  
  =item Binding Keys
  
  =over 4
  
  =item C<bind_key(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key(int key, FunctionPtr|str function,
  			    Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the C<FUNCTION>.  C<FUNCTION> is the name added by the
  C<add_defun> method.  If optional argument C<MAP> is specified, binds
  in C<MAP>.  Returns non-zero in case of error.
  
  =item C<bind_key_if_unbound(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key_if_unbound(int key, FunctionPtr|str function,
  			    	       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<unbind_key(KEY [,MAP])>
  
  	int	rl_unbind_key(int key, Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the null function.  Returns non-zero in case of error.
  
  =item C<unbind_function(FUNCTION [,MAP])>
  
  	int	rl_unbind_function(FunctionPtr|str function,
  				   Keymap|str map = rl_get_keymap())
  
  =item C<unbind_command(COMMAND [,MAP])>
  
  	int	rl_unbind_command(str command,
  				  Keymap|str map = rl_get_keymap())
  
  =item C<bind_keyseq(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq(str keyseq, FunctionPtr|str function,
  			       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<set_key(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_set_key(str keyseq, FunctionPtr|str function,
  			   Keymap|str map = rl_get_keymap())	# GRL 4.2
  
  =item C<bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq_if_unbound(str keyseq, FunctionPtr|str function,
  					  Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<generic_bind(TYPE, KEYSEQ, DATA, [,MAP])>
  
  	int	rl_generic_bind(int type, str keyseq,
  				FunctionPtr|Keymap|str data,
  				Keymap|str map = rl_get_keymap())
  
  =item C<parse_and_bind(LINE)>
  
  	void	rl_parse_and_bind(str line)
  
  Parse C<LINE> as if it had been read from the F<~/.inputrc> file and
  perform any key bindings and variable assignments found.  For more
  detail see L<GNU Readline Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
  
  =item C<read_init_file([FILENAME])>
  
  	int	rl_read_init_file(str filename = '~/.inputrc')
  
  =back
  
  =item Associating Function Names and Bindings
  
  =over 4
  
  =item C<named_function(NAME)>
  
  	FunctionPtr rl_named_function(str name)
  
  =item C<get_function_name(FUNCTION)>
  
  	str	rl_get_function_name(FunctionPtr function)	# TRG orignal
  
  =item C<function_of_keyseq(KEYMAP [,MAP])>
  
  	(FunctionPtr|Keymap|str data, int type)
  		rl_function_of_keyseq(str keyseq,
  				      Keymap|str map = rl_get_keymap())
  
  =item C<invoking_keyseqs(FUNCTION [,MAP])>
  
  	(@str)	rl_invoking_keyseqs(FunctionPtr|str function,
  				    Keymap|str map = rl_get_keymap())
  
  =item C<function_dumper([READABLE])>
  
  	void	rl_function_dumper(int readable = 0)
  
  =item C<list_funmap_names>
  
  	void	rl_list_funmap_names()
  
  =item C<funmap_names>
  
  	(@str)	rl_funmap_names()
  
  =item C<add_funmap_entry(NAME, FUNCTION)>
  
  	int	rl_add_funmap_entry(char *name, FunctionPtr|str function)
  
  =back
  
  =item Allowing Undoing
  
  =over 4
  
  =item C<begin_undo_group>
  
  	int	rl_begin_undo_group()
  
  =item C<end_undo_group>
  
  	int	rl_end_undo_group()
  
  =item C<add_undo(WHAT, START, END, TEXT)>
  
  	int	rl_add_undo(int what, int start, int end, str text)
  
  =item C<free_undo_list>
  
  	void	rl_free_undo_list()
  
  =item C<do_undo>
  
  	int	rl_do_undo()
  
  =item C<modifying([START [,END]])>
  
  	int	rl_modifying(int start = 0, int end = rl_end)
  
  =back
  
  =item Redisplay
  
  =over 4
  
  =item C<redisplay>
  
  	void	rl_redisplay()
  
  =item C<forced_update_display>
  
  	int	rl_forced_update_display()
  
  =item C<on_new_line>
  
  	int	rl_on_new_line()
  
  =item C<on_new_line_with_prompt>
  
  	int	rl_on_new_line_with_prompt()			# GRL 4.1
  
  =item C<reset_line_state>
  
  	int	rl_reset_line_state()
  
  =item C<crlf>
  
  	int	rl_crlf()
  
  =item C<rl_show_char(C)>
  
  	int	rl_show_char(int c)
  
  =item C<message(FMT[, ...])>
  
  	int	rl_message(str fmt, ...)
  
  =item C<clear_message>
  
  	int	rl_clear_message()
  
  =item C<save_prompt>
  
  	void	rl_save_prompt()
  
  =item C<restore_prompt>
  
  	void	rl_restore_prompt()
  
  =item C<expand_prompt(PROMPT)>
  
  	int	rl_expand_prompt(str prompt)
  
  =item C<set_prompt(PROMPT)>
  
  	int	rl_set_prompt(const str prompt)			# GRL 4.2
  
  =back
  
  =item Modifying Text
  
  =over 4
  
  =item C<insert_text(TEXT)>
  
  	int	rl_insert_text(str text)
  
  =item C<delete_text([START [,END]])>
  
  	int	rl_delete_text(int start = 0, int end = rl_end)
  
  =item C<copy_text([START [,END]])>
  
  	str	rl_copy_text(int start = 0, int end = rl_end)
  
  =item C<kill_text([START [,END]])>
  
  	int	rl_kill_text(int start = 0, int end = rl_end)
  
  =item C<push_macro_input(MACRO)>
  
  	int	rl_push_macro_input(str macro)
  
  =back
  
  =item Character Input
  
  =over 4
  
  =item C<read_key>
  
  	int	rl_read_key()
  
  =item C<getc(STREAM)>
  
  	int	rl_getc(FILE *STREAM)
  
  =item C<stuff_char(C)>
  
  	int	rl_stuff_char(int c)
  
  =item C<execute_next(C)>
  
  	int	rl_execute_next(int c)
  
  =item C<clear_pending_input()>
  
  	int	rl_clear_pending_input()			# GRL 4.2
  
  =item C<set_keyboard_input_timeout(uSEC)>
  
  	int	rl_set_keyboard_input_timeout(int usec)		# GRL 4.2
  
  =back
  
  =item Terminal Management
  
  =over 4
  
  =item C<prep_terminal(META_FLAG)>
  
  	void	rl_prep_terminal(int META_FLAG)
  
  =item C<deprep_terminal()>
  
  	void	rl_deprep_terminal()
  
  =item C<tty_set_default_bindings(KMAP)>
  
  	void	rl_tty_set_default_bindings([Keymap KMAP])	# GRL 4.0
  
  =item C<tty_unset_default_bindings(KMAP)>
  
  	void	rl_tty_unset_default_bindings([Keymap KMAP])	# GRL 5.0
  
  =item C<reset_terminal([TERMINAL_NAME])>
  
  	int	rl_reset_terminal(str terminal_name = getenv($TERM))
  
  =back
  
  =item Utility Functions
  
  =over 4
  
  =item C<save_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_save_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<restore_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_restore_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<free(MEM)>
  
  	Not implemented since not required for Perl.
  	int	rl_(void *mem)					# GRL 6.0
  
  =item C<replace_line(TEXT [,CLEAR_UNDO])>
  
  	int	rl_replace_line(str text, int clear_undo)	# GRL 4.3
  
  =item C<extend_line_buffer(LEN)>
  
  	Not implemented since not required for Perl.
  	int	rl_extend_line_buffer(int len)
  
  =item C<initialize>
  
  	int	rl_initialize()
  
  =item C<ding>
  
  	int	rl_ding()
  
  =item C<alphabetic(C)>
  
  	int	rl_alphabetic(int C)				# GRL 4.2
  
  =item C<display_match_list(MATCHES [,LEN [,MAX]])>
  
  	void	rl_display_match_list(\@matches, len = $#maches, max) # GRL 4.0
  
  Since the first element of an array @matches as treated as a possible
  completion, it is not displayed.  See the descriptions of
  C<completion_matches()>.
  When C<MAX> is ommited, the max length of an item in @matches is used.
  
  =back
  
  =item Miscellaneous Functions
  
  =over 4
  
  =item C<macro_bind(KEYSEQ, MACRO [,MAP])>
  
  	int	rl_macro_bind(const str keyseq, const str macro, Keymap map)
  
  =item C<macro_dumper(READABLE)>
  
  	int	rl_macro_dumper(int readline)
  
  =item C<variable_bind(VARIABLE, VALUE)>
  
  	int	rl_variable_bind(const str variable, const str value)
  
  =item C<variable_value(VARIABLE)>
  
  	str	rl_variable_value(const str variable)		# GRL 5.1
  
  =item C<variable_dumper(READABLE)>
  
  	int	rl_variable_dumper(int readline)
  
  =item C<set_paren_blink_timeout(uSEC)>
  
  	int	rl_set_paren_blink_timeout(usec)		# GRL 4.2
  
  =item C<get_termcap(cap)>
  
  	str	rl_get_termcap(cap)
  
  =item C<clear_history>
  
      void	rl_clear_history()				# GRL 6.3
  
  =back
  
  =item Alternate Interface
  
  =over 4
  
  =item C<callback_handler_install(PROMPT, LHANDLER)>
  
  	void	rl_callback_handler_install(str prompt, pfunc lhandler)
  
  =item C<callback_read_char>
  
  	void	rl_callback_read_char()
  
  =item C<callback_handler_remove>
  
  	void	rl_callback_handler_remove()
  
  =back
  
  =back
  
  =item Readline Signal Handling
  
  =over 4
  
  =item C<cleanup_after_signal>
  
  	void	rl_cleanup_after_signal()			# GRL 4.0
  
  =item C<free_line_state>
  
  	void	rl_free_line_state()				# GRL 4.0
  
  =item C<reset_after_signal>
  
  	void	rl_reset_after_signal()				# GRL 4.0
  
  =item C<echo_signal_char>
  
  	void	rl_echo_signal_char(int sig)			# GRL 6.0
  
  =item C<resize_terminal>
  
  	void	rl_resize_terminal()				# GRL 4.0
  
  =item C<set_screen_size(ROWS, COLS)>
  
  	void	rl_set_screen_size(int ROWS, int COLS)		# GRL 4.2
  
  =item C<get_screen_size()>
  
  	(int rows, int cols)	rl_get_screen_size()		# GRL 4.2
  
  =item C<reset_screen_size()>
  
  	void	rl_reset_screen_size()				# GRL 5.1
  
  =item C<set_signals>
  
  	int	rl_set_signals()				# GRL 4.0
  
  =item C<clear_signals>
  
  	int	rl_clear_signals()				# GRL 4.0
  
  =back
  
  =item Completion Functions
  
  =over 4
  
  =item C<complete_internal([WHAT_TO_DO])>
  
  	int	rl_complete_internal(int what_to_do = TAB)
  
  =item C<completion_mode(FUNCTION)>
  
  	int	rl_completion_mode(FunctionPtr|str function)	# GRL 4.3
  
  =item C<completion_matches(TEXT [,FUNC])>
  
  	(@str)	rl_completion_matches(str text,
  				      pfunc func = filename_completion_function)
  
  =item C<filename_completion_function(TEXT, STATE)>
  
  	str	rl_filename_completion_function(str text, int state)
  
  =item C<username_completion_function(TEXT, STATE)>
  
  	str	rl_username_completion_function(str text, int state)
  
  =item C<list_completion_function(TEXT, STATE)>
  
  	str	list_completion_function(str text, int state)	# TRG original
  
  =back
  
  =item History Functions
  
  =over 4
  
  =item Initializing History and State Management
  
  =over 4
  
  =item C<using_history>
  
  	void	using_history()
  
  =item C<history_get_history_state>
  
  	NOT IMPLEMENTED YET!
  	HISTORY_STATE	*history_get_hitory_state()		# GRL 6.3
  
  =item C<history_set_history_state>
  
  	NOT IMPLEMENTED YET!
  	void	*history_set_hitory_state(HISTORY_STATE *state)	# GRL 6.3
  
  =back
  
  =item History List Management
  
  =over 4
  
  =item C<addhistory(STRING[, STRING, ...])>
  
  	void	add_history(str string)
  
  =item C<add_history_time(STRING)>
  
  	void	add_history_time(str string)			# GRL 5.0
  
  =item C<remove_history(WHICH)>
  
  	str	remove_history(int which)
  
  =item C<free_history(HISTENT)>
  
  	Not implemented since Term::ReadLine::Gnu does not support the
  	member 'data' of HIST_ENTRY structure, remove_history() covers it.
  	histdata_t	free_history_entry(HIST_ENTRY *histent)	# GRL 5.0
  
  =item C<replace_history_entry(WHICH, LINE)>
  
  	str	replace_history_entry(int which, str line)
  
  =item C<clear_history>
  
  	void	clear_history()
  
  =item C<StifleHistory(MAX)>
  
  	int	stifle_history(int max|undef)
  
  stifles the history list, remembering only the last C<MAX> entries.
  If C<MAX> is undef, remembers all entries.  This is a replacement
  of unstifle_history().
  
  =item C<unstifle_history>
  
  	int	unstifle_history()
  
  This is equivalent with 'stifle_history(undef)'.
  
  =item C<SetHistory(LINE1 [, LINE2, ...])>
  
  sets the history of input, from where it can be used if the actual
  C<readline> is present.
  
  =item C<history_is_stifled>
  
  	int	history_is_stifled()
  
  =back
  
  =item Information About the History List
  
  =over 4
  
  =item C<history_list>
  
  	Not implemented since not required for Perl.
  	HIST_ENTRY **history_list()
  
  =item C<where_history>
  
  	int	where_history()
  
  =item C<current_history>
  
  	str	current_history()
  
  =item C<history_get(OFFSET)>
  
  	str	history_get(offset)
  
  =item C<history_get_time(OFFSET)>
  
  	time_t	history_get_time(offset)			# GRL 5.0
  
  =item C<history_total_bytes>
  
  	int	history_total_bytes()
  
  =item C<GetHistory>
  
  returns the history of input as a list, if actual C<readline> is present.
  
  =back
  
  =item Moving Around the History List
  
  =over 4
  
  =item C<history_set_pos(POS)>
  
  	int	history_set_pos(int pos)
  
  =item C<previous_history>
  
  	str	previous_history()
  
  =item C<next_history>
  
  	str	next_history()
  
  =back
  
  =item Searching the History List
  
  =over 4
  
  =item C<history_search(STRING [,DIRECTION])>
  
  	int	history_search(str string, int direction = -1)
  
  =item C<history_search_prefix(STRING [,DIRECTION])>
  
  	int	history_search_prefix(str string, int direction = -1)
  
  =item C<history_search_pos(STRING [,DIRECTION [,POS]])>
  
  	int	history_search_pos(str string,
  				   int direction = -1,
  				   int pos = where_history())
  
  =back
  
  =item Managing the History File
  
  =over 4
  
  =item C<ReadHistory([FILENAME [,FROM [,TO]]])>
  
  	int	read_history(str filename = '~/.history',
  			     int from = 0, int to = -1)
  
  	int	read_history_range(str filename = '~/.history',
  				   int from = 0, int to = -1)
  
  adds the contents of C<FILENAME> to the history list, a line at a
  time.  If C<FILENAME> is false, then read from F<~/.history>.  Start
  reading at line C<FROM> and end at C<TO>.  If C<FROM> is omitted or
  zero, start at the beginning.  If C<TO> is omitted or less than
  C<FROM>, then read until the end of the file.  Returns true if
  successful, or false if not.  C<read_history()> is an aliase of
  C<read_history_range()>.
  
  =item C<WriteHistory([FILENAME])>
  
  	int	write_history(str filename = '~/.history')
  
  writes the current history to C<FILENAME>, overwriting C<FILENAME> if
  necessary.  If C<FILENAME> is false, then write the history list to
  F<~/.history>.  Returns true if successful, or false if not.
  
  
  =item C<append_history(NELEMENTS [,FILENAME])>
  
  	int	append_history(int nelements, str filename = '~/.history')
  
  =item C<history_truncate_file([FILENAME [,NLINES]])>
  
  	int	history_truncate_file(str filename = '~/.history',
  				      int nlines = 0)
  
  =back
  
  =item History Expansion
  
  =over 4
  
  =item C<history_expand(LINE)>
  
  	(int result, str expansion) history_expand(str line)
  
  Note that this function returns C<expansion> in scalar context.
  
  =item C<get_history_event(STRING, CINDEX [,QCHAR])>
  
  	(str text, int cindex) = get_history_event(str  string,
  						   int  cindex,
  						   char qchar = '\0')
  
  =item C<history_tokenize(LINE)>
  
  	(@str)	history_tokenize(str line)
  
  =item C<history_arg_extract(LINE, [FIRST [,LAST]])>
  
  	str history_arg_extract(str line, int first = 0, int last = '$')
  
  =back
  
  =back
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Variables
  
  Following GNU Readline/History Library variables can be accessed by a
  Perl program.  See L<GNU Readline Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/readline.html> and
  L<GNU History Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/history.html> for
  details of each variable.  You can access them with C<Attribs>
  methods.  Names of keys in this hash conform to standard conventions
  with the leading C<rl_> stripped.
  
  Examples:
  
      $attribs = $term->Attribs;
      $v = $attribs->{library_version};	# rl_library_version
      $v = $attribs->{history_base};	# history_base
  
  =over 4
  
  =item Readline Variables
  
  	str rl_line_buffer
  	int rl_point
  	int rl_end
  	int rl_mark
  	int rl_done
  	int rl_num_chars_to_read (GRL 4.1)
  	int rl_pending_input
  	int rl_dispatching
  	int rl_erase_empty_line (GRL 4.0)
  	str rl_prompt (read only)
  	str rl_display_prompt
  	int rl_already_prompted (GRL 4.1)
  	str rl_library_version (read only)
  	int rl_readline_version (read only)
  	int rl_gnu_readline_p (GRL 4.1, read only)
  	str rl_terminal_name
  	str rl_readline_name
  	filehandle rl_instream
  	filehandle rl_outstream
  	int rl_prefer_env_winsize (GRL 5.1)
  	pfunc rl_last_func (GRL 4.2, read only)
  	pfunc rl_startup_hook
  	pfunc rl_pre_input_hook (GRL 4.0)
  	pfunc rl_event_hook
  	pfunc rl_getc_function
  	pfunc rl_signal_event_hook (GRL 6.3)
  	pfunc rl_input_available_hook (GRL 6.3)
  	pfunc rl_redisplay_function
  	pfunc rl_prep_term_function (GRL 2.1)
  	pfunc rl_deprep_term_function (GRL 2.1)
  	Keymap rl_executing_keymap (read only)
  	Keymap rl_binding_keymap (read only)
  	str rl_executing_macro (GRL 4.2, read only)
  	int rl_executing_key (GRL 6.3, read only)
  	str rl_executing_keyseq (GRL 6.3, read only)
  	int rl_key_sequence_length (read only)
  	int rl_readline_state (GRL 4.2, read only)
  	int rl_explicit_arg (read only)
  	int rl_numeric_arg (read only)
  	int rl_editing_mode (read only)
  
  =item Signal Handling Variables
  
  	int rl_catch_signals (GRL 4.0)
  	int rl_catch_sigwinch (GRL 4.0)
  	int rl_change_environment (GRL 6.3)
  
  =item Completion Variables
  
  	pfunc rl_completion_entry_function
  	pfunc rl_attempted_completion_function
  	pfunc rl_filename_quoting_function
  	pfunc rl_filename_dequoting_function
  	pfunc rl_char_is_quoted_p
  	pfunc rl_ignore_some_completions_function
  	pfunc rl_directory_completion_hook
  	pfunc rl_directory_rewrite_hook (GRL 4.2)
  	pfunc rl_filename_stat_hook (GRL 6.3)
  	pfunc rl_filename_rewrite_hook (GRL 6.1)
  	pfunc rl_completion_display_matches_hook (GRL 4.0)
  	str rl_basic_word_break_characters
  	str rl_basic_quote_characters
  	str rl_completer_word_break_characters
  	pfunc rl_completion_word_break_hook (GRL 5.0)
  	str rl_completer_quote_characters
  	str rl_filename_quote_characters
  	str rl_special_prefixes
  	int rl_completion_query_items
  	int rl_completion_append_character
  	int rl_completion_suppress_append (GRL 4.3)
  	int rl_completion_quote_character (GRL 5.0)
  	int rl_completion_suppress_quote (GRL 5.0)
  	int rl_completion_found_quote (GRL 5.0)
  	int rl_completion_mark_symlink_dirs (GRL 4.3)
  	int rl_ignore_completion_duplicates
  	int rl_filename_completion_desired
  	int rl_filename_quoting_desired
  	int rl_attempted_completion_over
  	int rl_sort_completion_matches (GRL 6.0)
  	int rl_completion_type (read only)
  	int rl_completion_invoking_key (GRL 6.0, read only)
  	int rl_inhibit_completion
  
  =item History Variables
  
  	int history_base (read only)
  	int history_length (read only)
  	int history_max_entries (called `max_input_history', read only)
  	int history_write_timestamps (GRL 5.0)
  	char history_expansion_char
  	char history_subst_char
  	char history_comment_char
  	str history_word_delimiters (GRL 4.2)
  	str history_search_delimiter_chars
  	str history_no_expand_chars
  	int history_quotes_inhibit_expansion
  	pfunc history_inhibit_expansion_function
  
  =item Function References
  
  	rl_getc
  	rl_redisplay
  	rl_callback_read_char
  	rl_display_match_list
  	rl_filename_completion_function
  	rl_username_completion_function
  	list_completion_function
  	shadow_redisplay
  	Tk_getc
  
  =back
  
  =head2 Custom Completion
  
  In this section variables and functions for custom completion are
  described with examples.
  
  Most of descriptions in this section are cited from L<GNU Readline
  Library
  Manual|http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
  
  =over 4
  
  =item C<rl_completion_entry_function>
  
  This variable holds reference refers to a generator function for
  C<completion_matches()>.
  
  A generator function is called repeatedly from
  C<completion_matches()>, returning a string each time.  The arguments
  to the generator function are C<TEXT> and C<STATE>.  C<TEXT> is the
  partial word to be completed.  C<STATE> is zero the first time the
  function is called, allowing the generator to perform any necessary
  initialization, and a positive non-zero integer for each subsequent
  call.  When the generator function returns C<undef> this signals
  C<completion_matches()> that there are no more possibilities left.
  
  If the value is undef, built-in C<filename_completion_function> is
  used.
  
  A sample generator function, C<list_completion_function>, is defined
  in Gnu.pm.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_entry_function} =
  	$attribs->{list_completion_function};
      ...
      $attribs->{completion_word} =
  	[qw(reference to a list of words which you want to use for completion)];
      $term->readline("custom completion>");
  
  See also C<completion_matches>.
  
  =item C<rl_attempted_completion_function>
  
  A reference to an alternative function to create matches.
  
  The function is called with C<TEXT>, C<LINE_BUFFER>, C<START>, and
  C<END>.  C<LINE_BUFFER> is a current input buffer string.  C<START>
  and C<END> are indices in C<LINE_BUFFER> saying what the boundaries of
  C<TEXT> are.
  
  If this function exists and returns null list or C<undef>, or if this
  variable is set to C<undef>, then an internal function
  C<rl_complete()> will call the value of
  C<$rl_completion_entry_function> to generate matches, otherwise the
  array of strings returned will be used.
  
  The default value of this variable is C<undef>.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      sub sample_completion {
          my ($text, $line, $start, $end) = @_;
          # If first word then username completion, else filename completion
          if (substr($line, 0, $start) =~ /^\s*$/) {
      	    return $term->completion_matches($text,
  					     $attribs->{'username_completion_function'});
          } else {
      	    return ();
          }
      }
      ...
      $attribs->{attempted_completion_function} = \&sample_completion;
  
  =item C<completion_matches(TEXT, ENTRY_FUNC)>
  
  Returns an array of strings which is a list of completions for
  C<TEXT>.  If there are no completions, returns C<undef>.  The first
  entry in the returned array is the substitution for C<TEXT>.  The
  remaining entries are the possible completions.
  
  C<ENTRY_FUNC> is a generator function which has two arguments, and
  returns a string.  The first argument is C<TEXT>.  The second is a
  state argument; it is zero on the first call, and non-zero on
  subsequent calls.  C<ENTRY_FUNC> returns a C<undef> to the caller when
  there are no more matches.
  
  If the value of C<ENTRY_FUNC> is undef, built-in
  C<filename_completion_function> is used.
  
  C<completion_matches> is a Perl wrapper function of an internal
  function C<completion_matches()>.  See also
  C<$rl_completion_entry_function>.
  
  =item C<completion_function>
  
  A variable whose content is a reference to a function which returns a
  list of candidates to complete.
  
  This variable is compatible with C<Term::ReadLine::Perl> and very easy
  to use.
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_function} = sub {
  	my ($text, $line, $start) = @_;
  	return qw(a list of candidates to complete);
      }
  
  =item C<list_completion_function(TEXT, STATE)>
  
  A sample generator function defined by C<Term::ReadLine::Gnu>.
  Example code at C<rl_completion_entry_function> shows how to use this
  function.
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Specific Features
  
  =over 4
  
  =item C<Term::ReadLine::Gnu> Specific Functions
  
  =over 4
  
  =item C<CallbackHandlerInstall(PROMPT, LHANDLER)>
  
  This method provides the function C<rl_callback_handler_install()>
  with the following addtional feature compatible with C<readline>
  method; ornament feature, C<Term::ReadLine::Perl> compatible
  completion function, histroy expansion, and addition to history
  buffer.
  
  =item C<call_function(FUNCTION, [COUNT [,KEY]])>
  
  	int	rl_call_function(FunctionPtr|str function, count = 1, key = -1)
  
  =item C<rl_get_all_function_names>
  
  Returns a list of all function names.
  
  =item C<shadow_redisplay>
  
  A redisplay function for password input.  You can use it as follows;
  
  	$attribs->{redisplay_function} = $attribs->{shadow_redisplay};
  	$line = $term->readline("password> ");
  
  =item C<rl_filename_list>
  
  Returns candidates of filename to complete.  This function can be used
  with C<completion_function> and is implemented for the compatibility
  with C<Term::ReadLine::Perl>.
  
  =item C<list_completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Variables
  
  =over 4
  
  =item C<do_expand>
  
  When true, the history expansion is enabled.  By default false.
  
  =item C<completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =item C<completion_word>
  
  A reference to a list of candidates to complete for
  C<list_completion_function>.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Commands
  
  =over 4
  
  =item C<history-expand-line>
  
  The equivalent of the Bash C<history-expand-line> editing command.
  
  =item C<operate-and-get-next>
  
  The equivalent of the Korn shell C<operate-and-get-next-history-line>
  editing command and the Bash C<operate-and-get-next>.
  
  This command is bound to C<\C-o> by default for the compatibility with
  the Bash and C<Term::ReadLine::Perl>.
  
  =item C<display-readline-version>
  
  Shows the version of C<Term::ReadLine::Gnu> and the one of the GNU
  Readline Library.
  
  =item C<change-ornaments>
  
  Change ornaments interactively.
  
  =back
  
  =back
  
  =head1 FILES
  
  =over 4
  
  =item F<~/.inputrc>
  
  Readline init file.  Using this file it is possible that you would
  like to use a different set of key bindings.  When a program which
  uses the GNU Readline library starts up, the init file is read, and
  the key bindings are set.
  
  Conditional key binding is also available.  The program name which is
  specified by the first argument of C<new> method is used as the
  application construct.
  
  For example, when your program call C<new> method like this;
  
  	...
  	$term = new Term::ReadLine 'PerlSh';
  	...
  
  your F<~/.inputrc> can define key bindings only for it as follows;
  
  	...
  	$if PerlSh
  	Meta-Rubout: backward-kill-word
  	"\C-x\C-r": re-read-init-file
          "\e[11~": "Function Key 1"
  	$endif
  	...
  
  =back
  
  =head1 EXPORTS
  
  None.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Term::ReadLine::Gnu Project Home Page|http://sourceforge.net/projects/perl-trg/>
  
  =item L<GNU Readline Library Manual|http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>
  
  =item L<GNU History Library Manual|http://cnswww.cns.cwru.edu/php/chet/readline/history.html>
  
  =item Sample and test programs (F<eg/*> and F<t/*>) in L<the C<Term::ReadLine::Gnu> distribution|http://search.cpan.org/dist/Term-ReadLine-Gnu/>
  
  =item L<Term::ReadLine|http://search.cpan.org/dist/Term-ReadLine/>
  
  =item Works which use Term::ReadLine::Gnu
  
  =over 4
  
  =item L<Perl Debugger|http://perldoc.perl.org/perldebug.html>
  
  	perl -d
  
  =item L<Perl Shell (psh)|http://gnp.github.io/psh/>
  
  The Perl Shell is a shell that combines the interactive nature of a
  Unix shell with the power of Perl.
  
  A programmable completion feature compatible with bash is implemented.
  
  =item L<SPP (Synopsys Plus Perl)|http://vlsiweb.stanford.edu/~jsolomon/SPP/>
  
  SPP (Synopsys Plus Perl) is a Perl module that wraps around Synopsys'
  shell programs.  SPP is inspired by the original dc_perl written by
  Steve Golson, but it's an entirely new implementation.  Why is it
  called SPP and not dc_perl?  Well, SPP was written to wrap around any
  of Synopsys' shells.
  
  =item L<PFM (Personal File Manager for UnixE<sol>Linux)|http://p-f-m.sourceforge.net/>
  
  Pfm is a terminal-based file manager written in Perl, based on PFM.COM
  for MS-DOS (originally by Paul Culley and Henk de Heer).
  
  =item L<The soundgrab|http://brittonkerin.com/soundgrab/soundgrab.html>
  
  soundgrab is designed to help you slice up a big long raw audio file
  (by default 44.1 kHz 2 channel signed sixteen bit little endian) and
  save your favorite sections to other files. It does this by providing
  you with a cassette player like command line interface.
  
  =item L<PDL (The Perl Data Language)|http://pdl.perl.org/>
  
  PDL (``Perl Data Language'') gives standard Perl the ability to
  compactly store and speedily manipulate the large N-dimensional data
  arrays which are the bread and butter of scientific computing.
  
  =item L<PIQT (Perl Interactive DBI Query Tool)|http://piqt.sourceforge.net/>
  
  PIQT is an interactive query tool using the Perl DBI database
  interface. It supports ReadLine, provides a built in scripting language
  with a Lisp like syntax, an online help system, and uses wrappers to
  interface to the DBD modules.
  
  =item L<vshnu (the New Visual Shell)|http://www.cs.indiana.edu/~kinzler/vshnu/>
  
  A visual shell and CLI shell supplement.
  
  =item Distributions which depend on Term::ReadLine::Gnu on L<CPAN|http://www.cpan.org/>
  
  L<https://metacpan.org/requires/distribution/Term-ReadLine-Gnu>
  
  =back
  
  If you know any other works which can be listed here, please let me
  know.
  
  =back
  
  =head1 AUTHOR
  
  Hiroo Hayashi C<E<lt>hiroo.hayashi@computer.orgE<gt>>
  
  L<http://search.cpan.org/~hayashi/>
  
  =head1 TODO
  
  GTK+ support in addition to Tk.
  
  =head1 BUGS
  
  C<rl_add_defun()> can define up to 16 functions.
  
  Some functions and variables do not have test code yet.  Your
  contribution is welcome.  See F<t/readline.t> for details.
  
  If the pager command (| or ||) in Perl debugger causes segmentation
  fault, you need to fix F<perl5db.pl>.  See
  L<https://rt.perl.org/Public/Bug/Display.html?id=121456> for details.
  
  =head1 LICENSE
  
  Copyright (c) 2014 Hiroo Hayashi.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_TERM_READLINE_GNU

$fatpacked{"x86_64-linux/Term/ReadLine/Gnu/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_TERM_READLINE_GNU_XS';
  #!/usr/local/bin/perl
  #
  #	XS.pm : perl function definition for Term::ReadLine::Gnu
  #
  #	$Id: XS.pm 468 2014-03-23 11:56:58Z hayashi $
  #
  #	Copyright (c) 2014 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  
  package Term::ReadLine::Gnu::XS;
  
  use Carp;
  use strict;
  use warnings;
  use AutoLoader 'AUTOLOAD';
  
  use vars qw($VERSION);
  $VERSION='1.24';	# added for CPAN
  
  # make aliases
  use vars qw(%Attribs);
  *Attribs = \%Term::ReadLine::Gnu::Attribs;
  
  use vars qw(*read_history);
  *read_history = \&read_history_range;
  
  # alias for 8 characters limitation imposed by AutoSplit
  use vars qw(*rl_unbind_key *rl_unbind_function *rl_unbind_command
  	    *history_list *history_arg_extract);
  *rl_unbind_key = \&unbind_key;
  *rl_unbind_function = \&unbind_function;
  *rl_unbind_command = \&unbind_command;
  *history_list = \&hist_list;
  *history_arg_extract = \&hist_arg_extract;
  
  # For backward compatibility.  Using these name (*_in_map) is deprecated.
  use vars qw(*rl_unbind_function_in_map *rl_unbind_command_in_map);
  *rl_unbind_function_in_map = \&unbind_function;
  *rl_unbind_command_in_map  = \&unbind_command;
  
  rl_add_defun('history-expand-line',	 \&history_expand_line);
  # bind operate-and-get-next to \C-o by default for the compatibility
  # with bash and Term::ReadLine::Perl
  rl_add_defun('operate-and-get-next',	 \&operate_and_get_next, ord "\co");
  rl_add_defun('display-readline-version', \&display_readline_version);
  rl_add_defun('change-ornaments',	 \&change_ornaments);
  
  # for ornaments()
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  # string encoded:
  my $rl_term_set = ',,,';
  
  # These variables are used by completion functions.  Don't use for
  # other purpose.
  my $_i;
  my @_matches;
  my @_tstrs;
  my $_tstrs_init = 0;
  
  1;
  
  # Uncomment the following line to enable AutoSplit.  If you are using
  # AutoLoader.pm distributed with Perl 5.004 or earlier, you must
  # update AutoLoader.pm due to its bug.
  
  #__END__
  
  
  #
  #	Readline Library function wrappers
  #
  
  # Convert keymap name to Keymap if the argument is not reference to Keymap
  sub _str2map ($) {
      return ref $_[0] ? $_[0]
  	: (rl_get_keymap_by_name($_[0]) || carp "unknown keymap name \`$_[0]\'\n");
  }
  
  # Convert function name to Function if the argument is not reference
  # to Function
  sub _str2fn ($) {
      return ref $_[0] ? $_[0]
  	: (rl_named_function($_[0]) || carp "unknown function name \`$_[0]\'\n");
  }
  
  sub rl_copy_keymap ($)    { return _rl_copy_keymap(_str2map($_[0])); }
  sub rl_discard_keymap ($) { return _rl_discard_keymap(_str2map($_[0])); }
  sub rl_set_keymap ($)     { return _rl_set_keymap(_str2map($_[0])); }
  
  # rl_bind_key
  sub rl_bind_key ($$;$) {
      if (defined $_[2]) {
  	return _rl_bind_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_key_if_unbound
  sub rl_bind_key_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_key_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_unbind_key
  sub unbind_key ($;$) {
      if (defined $_[1]) {
  	return _rl_unbind_key($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_key($_[0]);
      }
  }
  
  # rl_unbind_function
  sub unbind_function ($;$) {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_function() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_function($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_function($_[0]);
      }
  }
  
  # rl_unbind_command
  sub unbind_command ($;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_command() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_command($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_command($_[0]);
      }
  }
  
  # rl_bind_keyseq
  sub rl_bind_keyseq ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_set_key ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_set_key() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_set_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_set_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_keyseq_if_unbound
  sub rl_bind_keyseq_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_macro_bind ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if (defined $_[2]) {
  	return _rl_macro_bind($_[0], $_[1], _str2map($_[2]));
      } else {
  	return _rl_macro_bind($_[0], $_[1]);
      }
  }
  
  sub rl_generic_bind ($$$;$) {
      if      ($_[0] == Term::ReadLine::Gnu::ISFUNC) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISKMAP) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISMACR) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_macro($_[1], $_[2], _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_macro($_[1], $_[2]);
  	}
      } else {
  	carp("Term::ReadLine::Gnu::rl_generic_bind: invalid \`type\'\n");
      }
  }
  
  sub rl_call_function ($;$$) {
      if (defined $_[2]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1], $_[2]);
      } elsif (defined $_[1]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1]);
      } else {
  	return _rl_call_function(_str2fn($_[0]));
      }
  }
  
  sub rl_invoking_keyseqs ($;$) {
      if (defined $_[1]) {
  	return _rl_invoking_keyseqs(_str2fn($_[0]), _str2map($_[1]));
      } else {
  	return _rl_invoking_keyseqs(_str2fn($_[0]));
      }
  }
  
  sub rl_add_funmap_entry ($$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_add_funmap_entry() is not supported.  Ignored\n";
  	return;
      }
      return _rl_add_funmap_entry($_[0], _str2fn($_[1]));
  }
  
  sub rl_tty_set_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_tty_set_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_set_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_set_defaut_bindings();
      }
  }
  
  sub rl_tty_unset_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_tty_unset_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_unset_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_unset_defaut_bindings();
      }
  }
  
  sub rl_message {
      my $fmt = shift;
      my $line = sprintf($fmt, @_);
      _rl_message($line);
  }
  
  sub rl_completion_mode {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.3) {
  	carp "rl_completion_mode() is not supported.  Ignored\n";
  	return;
      }
      return _rl_completion_mode(_str2fn($_[0]));
  }
  
  #
  #	for compatibility with Term::ReadLine::Perl
  #
  sub rl_filename_list {
      my ($text) = @_;
  
      # lcd : lowest common denominator
      my ($lcd, @matches) = rl_completion_matches($text,
  						\&rl_filename_completion_function);
      return @matches ? @matches : $lcd;
  }
  
  #
  #	History Library function wrappers
  #
  # history_list
  sub hist_list () {
      my ($i, $history_base, $history_length, @d);
      $history_base   = $Attribs{history_base};
      $history_length = $Attribs{history_length};
      for ($i = $history_base; $i < $history_base + $history_length; $i++) {
  	push(@d, history_get($i));
      }
      @d;
  }
  
  # history_arg_extract
  sub hist_arg_extract ( ;$$$ ) {
      my ($line, $first, $last) = @_;
      $line  = $_      unless defined $line;
      $first = 0       unless defined $first;
      $last  = ord '$' unless defined $last; # '
      $first = ord '$' if defined $first and $first eq '$'; # '
      $last  = ord '$' if defined $last  and $last  eq '$'; # '
      &_history_arg_extract($line, $first, $last);
  }
  
  sub get_history_event ( $$;$ ) {
      _get_history_event($_[0], $_[1], defined $_[2] ? ord $_[2] : 0);
  }
  
  #
  #	Ornaments
  #
  
  # This routine originates in Term::ReadLine.pm.
  
  # Debian GNU/Linux discourages users from using /etc/termcap.  A
  # subroutine ornaments() defined in Term::ReadLine.pm uses
  # Term::Caps.pm which requires /etc/termcap.
  
  # This module calls termcap (or its compatible) library, which the GNU
  # Readline Library already uses, instead of Term::Caps.pm.
  
  # Some terminals do not support 'ue' (underline end).
  use vars qw(%term_no_ue);
  %term_no_ue = ( kterm => 1 );
  
  sub ornaments {
      return $rl_term_set unless @_;
      $rl_term_set = shift;
      $rl_term_set ||= ',,,';
      $rl_term_set = $term_no_ue{$ENV{TERM}} ? 'us,me,,' : 'us,ue,,'
  	if $rl_term_set eq '1';
      my @ts = split /,/, $rl_term_set, 4;
      my @rl_term_set
  	= map {
  	    # non-printing characters must be informed to readline
  	    my $t;
  	    ($_ and $t = tgetstr($_))
  		? (Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE
  		   . $t
  		   . Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE)
  		    : '';
  	} @ts;
      $Attribs{term_set} = \@rl_term_set;
      return $rl_term_set;
  }
  
  #
  #	a sample custom function
  #
  
  # The equivalent of the Bash shell M-^ history-expand-line editing
  # command.
  
  # This routine was borrowed from bash.
  sub history_expand_line {
      my ($count, $key) = @_;
      my ($expanded, $new_line) = history_expand($Attribs{line_buffer});
      if ($expanded > 0) {
    	rl_modifying(0, $Attribs{end}); # save undo information
    	$Attribs{line_buffer} = $new_line;
      } elsif ($expanded < 0) {
    	my $OUT = $Attribs{outstream};
    	print $OUT "\n$new_line\n";
    	rl_on_new_line();
      }				# $expanded == 0 : no change
  }
  
  # The equivalent of the Korn shell C-o operate-and-get-next-history-line
  # editing command. 
  
  # This routine was borrowed from bash.
  sub operate_and_get_next {
      my ($count, $key) = @_;
  
      my $saved_history_line_to_use = -1;
      my $old_rl_startup_hook;
  
      # Accept the current line.
      rl_call_function('accept-line', 1, $key);
  
      # Find the current line, and find the next line to use. */
      my $where = where_history();
      if ((history_is_stifled()
  	 && ($Attribs{history_length} >= $Attribs{max_input_history}))
  	|| ($where >= $Attribs{history_length} - 1)) {
  	$saved_history_line_to_use = $where;
      } else {
  	$saved_history_line_to_use = $where + 1;
      }
      $old_rl_startup_hook = $Attribs{startup_hook};
      $Attribs{startup_hook} = sub {
  	if ($saved_history_line_to_use >= 0) {
  	    rl_call_function('previous-history',
  			     $Attribs{history_length}
  			     - $saved_history_line_to_use,
  			     0);
  	    $Attribs{startup_hook} = $old_rl_startup_hook;
  	    $saved_history_line_to_use = -1;
  	}
      };
  }
  
  sub display_readline_version {	# show version
      my($count, $key) = @_;	# ignored in this function
      my $OUT = $Attribs{outstream};
      print $OUT
  	("\nTerm::ReadLine::Gnu version: $Term::ReadLine::Gnu::VERSION");
      print $OUT
  	("\nGNU Readline Library version: $Attribs{library_version}\n");
      rl_on_new_line();
  }
  
  # sample function of rl_message()
  sub change_ornaments {
      my($count, $key) = @_;	# ignored in this function
      rl_save_prompt;
      rl_message("[S]tandout, [U]nderlining, [B]old, [R]everse, [V]isible bell: ");
      my $c = chr rl_read_key;
      if ($c =~ /s/i) {
  	ornaments('so,me,,');
      } elsif ($c =~ /u/i) {
  	ornaments('us,me,,');
      } elsif ($c =~ /b/i) {
  	ornaments('md,me,,');
      } elsif ($c =~ /r/i) {
  	ornaments('mr,me,,');
      } elsif ($c =~ /v/i) {
  	ornaments('vb,,,');
      } else {
  	rl_ding;
      }
      rl_restore_prompt;
      rl_clear_message;
  }
  
  #
  #	for tkRunning
  #
  sub Tk_getc {
      &Term::ReadLine::Tk::Tk_loop
  	if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
      my $FILE = $Attribs{instream};
      return rl_getc($FILE);
  }
  
  # redisplay function for secret input like password
  # usage:
  #	$a->{redisplay_function} = $a->{shadow_redisplay};
  #	$line = $t->readline("password> ");
  sub shadow_redisplay {
      @_tstrs = _tgetstrs() unless $_tstrs_init;
      # remove prompt start/end mark from prompt string
      my $prompt = $Attribs{prompt}; my $s;
      $s = Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE; $prompt =~ s/$s//g;
      $s = Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE;   $prompt =~ s/$s//g;
      my $OUT = $Attribs{outstream};
      my $oldfh = select($OUT); $| = 1; select($oldfh);
      print $OUT ($_tstrs[0],	# carriage return
  		$_tstrs[1],	# clear to EOL
  		$prompt, '*' x length($Attribs{line_buffer}));
      print $OUT ($_tstrs[2]	# cursor left
  		x (length($Attribs{line_buffer}) - $Attribs{point}));
      $oldfh = select($OUT); $| = 0; select($oldfh);
  }
  
  sub _tgetstrs {
      my @s = (tgetstr('cr'),	# carriage return
  	     tgetstr('ce'),	# clear to EOL
  	     tgetstr('le'));	# cursor left
      warn <<"EOM" unless (defined($s[0]) && defined($s[1]) && defined($s[2]));
  Your terminal 'TERM=$ENV{TERM}' does not support enough function.
  Check if your environment variable 'TERM' is set correctly.
  EOM
      # suppress warning "Use of uninitialized value in print at ..."
      $s[0] = $s[0] || ''; $s[1] = $s[1] || ''; $s[2] = $s[2] || '';
      $_tstrs_init = 1;
      return @s;
  }
  
  # callback handler wrapper function for CallbackHandlerInstall method
  sub _ch_wrapper {
      my $line = shift;
  
      if (defined $line) {
  	if ($Attribs{do_expand}) {
  	    my $result;
  	    ($result, $line) = history_expand($line);
  	    my $outstream = $Attribs{outstream};
  	    print $outstream "$line\n" if ($result);
  
  	    # return without adding line into history
  	    if ($result < 0 || $result == 2) {
  		return '';	# don't return `undef' which means EOF.
  	    }
  	}
  
  	# add to history buffer
  	add_history($line) 
  	    if ($Attribs{MinLength} > 0
  		&& length($line) >= $Attribs{MinLength});
      }
      &{$Attribs{_callback_handler}}($line);
  }
  
  #
  #	List Completion Function
  #
  sub list_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      $_i = $state ? $_i + 1 : 0;	# clear counter at the first call
      my $cw = $Attribs{completion_word};
      for (; $_i <= $#{$cw}; $_i++) {
  	return $cw->[$_i] if ($cw->[$_i] =~ /^\Q$text/);
      }
      return undef;
  }
  
  #
  #	wrapper completion function of 'completion_function'
  #	for compatibility with Term::ReadLine::Perl
  #
  sub _trp_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      my $cf;
      return undef unless defined ($cf = $Attribs{completion_function});
  
      if ($state) {
  	$_i++;
      } else {
  	# the first call
  	$_i = 0;		# clear index
  	@_matches = &$cf($text,
  			 $Attribs{line_buffer},
  			 $Attribs{point} - length($text));
  	# return here since $#_matches is 0 instead of -1 when
  	# @_matches = undef
  	return undef unless defined $_matches[0];
      }
  
      return $_matches[$_i];
  }
  
  1;
  
  __END__
X86_64-LINUX_TERM_READLINE_GNU_XS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#Ask and find! Version 4.5 stable.
#2014 by Luke V. Franklin.

#modules
#-----------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use feature 'say';
use feature 'fc';
use IO::All;
use Cwd 'abs_path';
use File::Basename;
use Term::ReadLine;
use POSIX;

#local variables and start
#-----------------------------------------------------------------------------

my $default;
my $dirfile;
my $dirdirfile;

my $kw_name = 'keywords.txt';#keyword name
our $adj_kw_name = adjust_path('a', $kw_name);

my $df_name = 'dirfile.txt'; #dirfile name
my $adj_df_name = adjust_path('a', $df_name);

if (-e $adj_df_name ){
  
  $dirfile = io->file($adj_df_name);
  
  while (my $line = $dirfile->chomp->getline()) {
    
    $line = adjust_path('a', $line);
    
    $default = $line;
    last;
    
  } 
  $dirdirfile = $adj_df_name;
}

else{

  my $answer = yesno("Do you want create the file '$df_name' to store your default directory?",
   "It will be created in $ENV{ PWD }");      
  
  if ($answer){
      io->file($adj_df_name)->utf8->print($adj_kw_name); 
      $default = $adj_kw_name; 
  
      $dirdirfile = $adj_df_name;
      say "\n\tDefault directory file created successfully!\n";
  }
  else{
      say "Aborting...";
      exit();
   }
}  

unless ( $default || (-e $default) || length($default) ){
 
  say "\n\tInvalid directory, check your $df_name and check it for errors.\n";
  exit();
}

my $dir = $default;

$dir = adjust_path('a', $dir);

about();

#subroutines
#-----------------------------------------------------------------------------

#shows about message
sub about{
   
   say "\n\tAsk and find! Version 4.5 - implementation of auto complete and";
   say "\tkey movements through standard input";
   say "\n\t2014 by Luke V. Franklin.";
   
   say "\n\tkey:value - store pairs key/value.";
   say "\tks <key> - search the keys in the current file.";
   say "\ths - histogram of the keys.";
   say "\te - edit the specified key.";
   say "\tcd - change the default dir.";
   say "\td - delete the specified key.";
   say "\tdf - delete the current file loaded.";
   say "\tl - load other keyword files.";
   say "\ta/h - show this message.";
   say "\tp - show current work directory.";
   say "\tls - show the quantity of lines of the file.";
   say "\tk - show all keys of the file.";
   say "\tv <pattern> - search for patterns in values.";
   say "\ts - sort the file alfabetically.";
   say "\tq/ex - exit the program.\n";
   say "\tHints, doubts and bugs: report to <lukevinc9\@gmail.com>\n";
   
   return 1;
}

#count lines of the file
sub count_lines
{
    my ($filename) = @_;

    open my $fh, '<', $filename or die "Error in line counting! Aborting!";

    my $count = 0;
    $count++ while (my $l = <$fh>);
    
    close($fh);

    return $count;
}

#a simple yes/no dialog, return 1 for y and 0 for anything else
sub yesno{
   my $single = pop;
   my @msgs = @_;
   
   say foreach (@msgs);
     
   print $single." (y/N): ";
   chomp( my $yesno = <STDIN> );
   
   return 1 if ($yesno eq 'y');
   return 0;
}

#show a question and wait for answer, then return it.
sub question
{
   my $single = pop;
   my @msgs = @_;
    
   say foreach (@msgs);
     
   print $single." : ";

   chomp(my $response = <STDIN>);
   
   return $response;
}

#make conversions between abs and compact filepaths
sub adjust_path 
{   
   my $mode = shift;
   my $directory = shift;
   
   $directory = $ENV{PWD}."/$directory" if ($directory !~ m/^(\\|\/)/ );  
   
   if ($mode eq 'c'){#compact mode
         
      $directory =~ s/$ENV{PWD}/\./g;
      $directory =~ s/$ENV{HOME}/~/g;
   }
   
   elsif ($mode eq 'a'){#absolute
      
      $directory =~ s/^\.(\W)/$ENV{PWD}\//;        
      $directory =~ s/~/$ENV{HOME}/;
      
   }
   
   return $directory;
}

sub keywords{
   
   my $filename = shift;
   
   my $file = io->file($filename);
   my @keys;
   while (my $line = $file->chomp->getline()) {
   
      my ($key, $value) = split ':', $line;
      push @keys, lc($key);
   }
   
   return \@keys;

}

#main loop
#------------------------------------------------------------------------------

MAIN:while ( 1 ) {
   
   my $dirname = $dir;
   
   $dirname = adjust_path('c', $dirname);
       
   unless ( -e $dir){
              
      my $answer = yesno("Do you want create '$kw_name' to store your data?",
      "It will be created in $dirname.");      
  
      if ($answer){
          io->file($dir)->utf8->print("");
             
          say "\n\tFile created successfully: $dirname\n";  
          next MAIN;  
         
      }
      else{
         say "Aborting...";
         exit();
      }
  }       
   
   my $file = io->file($dir);
   
   my $term = new Term::ReadLine 'sample';
   my $attribs = $term->Attribs;

   $attribs->{completion_entry_function} =
       $attribs->{list_completion_function};

   my $keywords = keywords($adj_kw_name);
   $attribs->{completion_word} = $keywords;
   chomp( my $entry = $term->readline("<Prompt\@$dirname>") );
    
   if($entry eq ''){
    
         say "\n\tError: blank key. Try another.\n";
         
         next MAIN;
   }
      
   my $count = @{[$entry =~ /:/g]};#count number of colons
    
   if ( $count > 1 ){
      say "\n\tError: more than one colon found! Try again!\n";
      
      next MAIN;
   }
   
   #keys menu
#------------------------------------------------------------------------------   
   if ($entry =~ /ks (.*)/) {
           
      print "\n";
      while (my $line = $file->chomp->getline()) {
         
         my @key = split ':', $line;
         if ($1){
            
            if ($key[0] =~ /\b\Q${1}\E/i){
            
               say "\t$key[0]";
               $count++;
            }
         }
      }
      say "\n\tKeys found: $count\n";      
      
      next MAIN;    
   }

#quit menu
#------------------------------------------------------------------------------     
      
   last MAIN if ($entry =~ /^(ex|q)$/);

  #histogram menu
#------------------------------------------------------------------------------     
   
   if ($entry eq 'hs') {
     
     my %hist;
     my @alfa = 'A' .. 'Z';
     my $total;
     while (my $line = $file->chomp->getline()) {
  
        my ($key, $value) = split ':', $line;
          
        my $initial = substr( $key, 0, 1 );
     
        foreach (@alfa){
     
          if ($key =~ m/^TO (.*)/){
            
            $hist{'Verbs'}++;
            last;
          }  
                    
          if ($initial eq $_){
           
             $hist{$_}++;
             $total++;
             last;  
          }
        }  
        
      }  
      my $sum = 0;
      my $count2 = 0;
      
      print "\n\t";
      foreach (sort keys %hist ){
       
        my $pc = ( $hist{$_} / $total ) * 100;
        
        $pc = ceil( $pc );
        
        $sum += $pc;
        print "$_: ", "*" x $pc, " ($pc) : "; 
        
        $count2++;
        
        if ($count2 > 1){
         print "\n\t";
         $count2 = 0;
        }
               
      }
      
      say "\n\n\tTotal: $sum\n";
      say "\tHint: sort the file to obtain better accuracy.\n";
      next MAIN;
   }   

   #edit menu
#------------------------------------------------------------------------------     
   if ($entry eq 'e') {
            
      my $entry = question("\n\tWhich key do you want to edit?");
          
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         if ($entry eq $word) {#if key is in keywords
            print "\n\tText for '$word': ";
            
            chomp( my $entry = <STDIN>);
                  
            $count = @{[$entry =~ /:/g]};#count number of colons
            
            if ($count) {
               say "\n\tError: colon found in text.\n";          
               
               next MAIN;
            }
                        
            my $answer = yesno("Are you sure do you want to edit this key?");
            
            if ($answer){
               $text = $entry;
               $count++;
            }
            
            else{
               say "\n\tKey edit canceled!\n";
               next MAIN;
            }
                    
         }
         
         chomp( $text );    
         $keyvalue{$word} = $text;
      }
              
      unless ($count){
      
         say "\n\tError: key for edition not found!\n";
         next 
      }
      io->file($dir)->utf8->print("");  
          
      foreach (sort keys %keyvalue){
         
         "$_:$keyvalue{ $_ }\n" >> io->file($dir);
      }
      say "\n\tKey updated successfully in $dirname!'\n";                
      
      next MAIN;   
   }

 #change dir menu
#------------------------------------------------------------------------------   
   if ($entry eq 'cd') {
           
      my $entry2 = question("Which is the new default directory?");
           
      my $answer = yesno("\n\tAre you sure do you want change the default dir?");
      
      unless ($answer){
          say "\n\tDirectory change canceled.\n";    
          next MAIN;
      }       
            
      $entry2 = adjust_path('a', $entry2);
      
      unless (-e $entry2){
         say "\n\tError: invalid directory!\n";       
       
         next MAIN;  
      }
      
      $dir = $entry2;
      io->file($dirdirfile)->utf8->print($entry2); 
        
      say "\n\tDefault file changed successfully in $dirdirfile\n";
      next MAIN;   
   } 

   #load menu
#------------------------------------------------------------------------------   
   if ($entry eq 'l') {
      
      print ": ";
      my $entry = question("\n\tType the dir/file do you want to load your keys");
     
      my $safe = $dir;
      
      $dir = $entry;
      
      $dir = adjust_path('a', $dir);
            
      $dir = abs_path($dir); #or die "$!";#add absolute path
      my $dirname = $dir;
      $dirname = adjust_path('c', $dirname);
      
      
      unless ( -e $dir){
         my $basename = basename($dir);

         my $answer = yesno("Do you want to create the file '$basename' to store your data?",
            "It will be created in $dirname.");
         
         if ( $answer ){
            io->file($dir)->utf8->print(""); 
            say "\n\tFile created successfully: $dirname\n"; 
         
            next MAIN;
         
         }
         else{
             say "\n\tProgram load canceled.\n";
              
             $dir = $safe;
             next MAIN;
         }
                 
      }
           
      if ( -d $dir ){
            say "\n\tError: $dirname is a directory!\n";
            
            $dir = $safe;
            next MAIN;
      }   
      
            
      say "\n\t$dirname : ".count_lines($dir)." key(s) loaded!\n";
      
      next MAIN;      
   }
   
   #delete menu
#------------------------------------------------------------------------------   
   if ($entry eq 'd') {
            
      my $entry = question("\n\tWhich key do you want to delete?"); 
        
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         if ($entry =~ /\b$word\b/i) {#if key is in keywords
                    
            my $answer = yesno("\tAre you sure do you want to delete '$entry'?");
            
            
            if ( $answer ){
               say "\n\tKey '$word' deleted successfully!\n";
            
            }
            else{
               say "\n\tError: key '$word' not deleted!\n";
               next MAIN;
            }
                                           
            $count++;
            next;
         }
         chomp( $text );    
         $keyvalue{ $word } = $text;
      }
              
      unless ($count){
              
         say "\n\tError: key doesn't exists!\n";
         next MAIN;
      }
           
      io->file($dir)->utf8->print("");  
         
      foreach (sort keys %keyvalue){
         
         "$_:$keyvalue{ $_ }\n" >> io->file( $dir );
      }
                     
      next MAIN;   
   }

   #delete file menu
#------------------------------------------------------------------------------   
   if ($entry eq 'df') {
     my $basename = basename($dir);
          
     my $answer = yesno("\tAre you sure do you want to delete '$basename'?");
     
     if ($answer){
         unlink $dir;
     
         say "\n\tFile '$basename' deleted successfully!\n";
         $dir = $default;    
          
         next MAIN;  
     }
     
     else{
         say "\n\tFile delete canceled.\n";
         next MAIN;
     }
   }

   #about menu
#------------------------------------------------------------------------------   
   if ($entry =~ m/^[ah]$/) {
         
      about();
      next MAIN;  
   }

   #pwd menu
#------------------------------------------------------------------------------   
   if ($entry eq 'p') {
      say "\n\tYou are here: $ENV{PWD}\n";
      
      next MAIN;
   }
    
   #line counting menu
#------------------------------------------------------------------------------ 
    if ($entry eq 'ls') {
      
      say "\n\t".count_lines( $dir )." line(s) found in $dir\n";
      next MAIN;
   }
   
  #keywords menu
#------------------------------------------------------------------------------ 
    if ($entry eq 'k') {
      
      my $space = 0;
      while (my $line = $file->chomp->getline()) {
      
         my @keys = split ':', $line;
         
         if (length($keys[0]) > $space){
            
            $space = length($keys[0]);
         }
      }

      print "\n";
      while (my $line = $file->chomp->getline()) {
         my @keys = split ':', $line;
         
         my $size = $space - length($keys[0]) + 1;
         printf "\t%s%${size}s", $keys[0], "";   
         if ($count > 1){
            say "";
            $count = 0;
            next;
         }
         
         $count++;   
      }
           
      say "\n\n\t".count_lines($dir)." key(s) found in $dirname.\n";
            
      next MAIN;
   }   

#value menu
#------------------------------------------------------------------------------ 
    if ($entry =~ m/v (.*)/) {
       my $count = 0;
       
       print "\n";
       while (my $line = $file->chomp->getline() ) {
  
          my ($key, $value) = split ':', $line;
                    
          if ($value =~ m/$1/){
            
            say "\t$key:$value"; 
            $count++;
          }
       }
       
       say "\n\t$count key(s) found.\n";
       next MAIN;
    }
 
 #sort menu
#------------------------------------------------------------------------------ 
    if ($entry eq 's') {
      $file = io->file($dir);
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         $keyvalue{ $word } = $text;
      }
      
      io->file($dir)->utf8->print("");
            
      foreach ( sort { fc($a) cmp fc($b)}keys %keyvalue){
         
         uc($_).":$keyvalue{ $_ }\n" >> io->file( $dir );
      }
      say "\n\tKeys sorted in '$dirname' successfully!\n";                
      
      next MAIN;
       
    }
   #search and keywords handling
#------------------------------------------------------------------------------     
   my ($key, $value) = split ':', $entry;   
      
   if ( $count ){#verification to see if keys already exists
      
      if (length($key) < 2 || length($value) < 2){

         say "\n\tError: invalid key or value!\n";
         next MAIN;
      }
      
      while (my $line = $file->chomp->getline()) {
      
         if ($line =~ m/^$key:/i){
            say "\n\tThe key '$key' already exists in $dirname! Try another.\n";
             
            next MAIN; 
         }
      }
           
      "$entry\n" >> io->file( $dir );
           
      say "\n\tThe key '$key' was stored with the value '$value' in $dirname!\n";
  }
  
  else{
     
      while (my $line = $file->chomp->getline()) {
      
         if ( $line =~ m/^\Q$key\E:/i ){
            
            my @lines = split ':', $line;
            say "Eco says: $lines[1]";#search and say
            next MAIN;
         }
      }
   
   say "\n\tError: key '$key' not found in $dirname!\n";
  }
}  
 
#exit message
#------------------------------------------------------------------------------
say "Exiting...";
