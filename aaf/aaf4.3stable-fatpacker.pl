#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"IO/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL';
  package IO::All;
  $IO::All::VERSION = '0.65';
  use 5.006001;
  use strict;
  use warnings;
  
  require Carp;
  # So one can use Carp::carp "$message" - without the parenthesis.
  sub Carp::carp;
  
  use IO::All::Base -base;
  
  use File::Spec();
  use Symbol();
  use Fcntl;
  use Cwd ();
  
  our @EXPORT = qw(io);
  
  #===============================================================================
  # Object creation and setup methods
  #===============================================================================
  my $autoload = {
      qw(
          touch file
  
          dir_handle dir
          All dir
          all_files dir
          All_Files dir
          all_dirs dir
          All_Dirs dir
          all_links dir
          All_Links dir
          mkdir dir
          mkpath dir
          next dir
  
          stdin stdio
          stdout stdio
          stderr stdio
  
          socket_handle socket
          accept socket
          shutdown socket
  
          readlink link
          symlink link
      )
  };
  
  # XXX - These should die if the given argument exists but is not a
  # link, dbm, etc.
  sub link {my $self = shift; require IO::All::Link; IO::All::Link::link($self, @_) }
  sub dbm {my $self = shift; require IO::All::DBM; IO::All::DBM::dbm($self, @_) }
  sub mldbm {my $self = shift; require IO::All::MLDBM; IO::All::MLDBM::mldbm($self, @_) }
  
  sub autoload {my $self = shift; $autoload }
  
  sub AUTOLOAD {
      my $self = shift;
      my $method = $IO::All::AUTOLOAD;
      $method =~ s/.*:://;
      my $pkg = ref($self) || $self;
      $self->throw(qq{Can't locate object method "$method" via package "$pkg"})
        if $pkg ne $self->package;
      my $class = $self->autoload_class($method);
      my $foo = "$self";
      bless $self, $class;
      $self->$method(@_);
  }
  
  sub autoload_class {
      my $self = shift;
      my $method = shift;
      my $class_id = $self->autoload->{$method} || $method;
      my $ucfirst_class_name = 'IO::All::' . ucfirst($class_id);
      my $ucfirst_class_fn = "IO/All/" . ucfirst($class_id) . ".pm";
      return $ucfirst_class_name if $INC{$ucfirst_class_fn};
      return "IO::All::\U$class_id" if $INC{"IO/All/\U$class_id\E.pm"};
      require IO::All::Temp;
      if (eval "require $ucfirst_class_name; 1") {
          my $class = $ucfirst_class_name;
          my $return = $class->can('new')
          ? $class
          : do { # (OS X hack)
              my $value = $INC{$ucfirst_class_fn};
              delete $INC{$ucfirst_class_fn};
              $INC{"IO/All/\U$class_id\E.pm"} = $value;
              "IO::All::\U$class_id";
          };
          return $return;
      }
      elsif (eval "require IO::All::\U$class_id; 1") {
          return "IO::All::\U$class_id";
      }
      $self->throw("Can't find a class for method '$method'");
  }
  
  sub new {
      my $self = shift;
      my $package = ref($self) || $self;
      my $new = bless Symbol::gensym(), $package;
      $new->package($package);
      $new->_copy_from($self) if ref($self);
      my $name = shift;
      return $name if UNIVERSAL::isa($name, 'IO::All');
      return $new->_init unless defined $name;
      return $new->handle($name)
        if UNIVERSAL::isa($name, 'GLOB') or ref(\ $name) eq 'GLOB';
      # WWW - link is first because a link to a dir returns true for
      # both -l and -d.
      return $new->link($name) if -l $name;
      return $new->file($name) if -f $name;
      return $new->dir($name) if -d $name;
      return $new->$1($name) if $name =~ /^([a-z]{3,8}):/;
      return $new->socket($name) if $name =~ /^[\w\-\.]*:\d{1,5}$/;
      return $new->pipe($name)
        if $name =~ s/^\s*\|\s*// or $name =~ s/\s*\|\s*$//;
      return $new->string if $name eq '$';
      return $new->stdio if $name eq '-';
      return $new->stderr if $name eq '=';
      return $new->temp if $name eq '?';
      $new->name($name);
      $new->_init;
  }
  
  sub _copy_from {
      my $self = shift;
      my $other = shift;
      for (keys(%{*$other})) {
          # XXX Need to audit exclusions here
          next if /^(_handle|io_handle|is_open)$/;
          *$self->{$_} = *$other->{$_};
      }
  }
  
  sub handle {
      my $self = shift;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  # Overloading support
  #===============================================================================
  my $old_warn_handler = $SIG{__WARN__};
  $SIG{__WARN__} = sub {
      if ($_[0] !~ /^Useless use of .+ \(.+\) in void context/) {
          goto &$old_warn_handler if $old_warn_handler;
          warn(@_);
      }
  };
  
  use overload '""' => 'overload_stringify';
  use overload '|' => 'overload_bitwise_or';
  use overload '<<' => 'overload_left_bitshift';
  use overload '>>' => 'overload_right_bitshift';
  use overload '<' => 'overload_less_than';
  use overload '>' => 'overload_greater_than';
  use overload '${}' => 'overload_string_deref';
  use overload '@{}' => 'overload_array_deref';
  use overload '%{}' => 'overload_hash_deref';
  use overload '&{}' => 'overload_code_deref';
  
  sub overload_bitwise_or {my $self = shift; $self->overload_handler(@_, '|') }
  sub overload_left_bitshift {my $self = shift; $self->overload_handler(@_, '<<') }
  sub overload_right_bitshift {my $self = shift; $self->overload_handler(@_, '>>') }
  sub overload_less_than {my $self = shift; $self->overload_handler(@_, '<') }
  sub overload_greater_than {my $self = shift; $self->overload_handler(@_, '>') }
  sub overload_string_deref {my $self = shift; $self->overload_handler(@_, '${}') }
  sub overload_array_deref {my $self = shift; $self->overload_handler(@_, '@{}') }
  sub overload_hash_deref {my $self = shift; $self->overload_handler(@_, '%{}') }
  sub overload_code_deref {my $self = shift; $self->overload_handler(@_, '&{}') }
  
  sub overload_handler {
      my ($self) = @_;
      my $method = $self->get_overload_method(@_);
      $self->$method(@_);
  }
  
  my $op_swap = {
      '>' => '<', '>>' => '<<',
      '<' => '>', '<<' => '>>',
  };
  
  sub overload_table {
      my $self = shift;
      (
          '* > *' => 'overload_any_to_any',
          '* < *' => 'overload_any_from_any',
          '* >> *' => 'overload_any_addto_any',
          '* << *' => 'overload_any_addfrom_any',
  
          '* < scalar' => 'overload_scalar_to_any',
          '* > scalar' => 'overload_any_to_scalar',
          '* << scalar' => 'overload_scalar_addto_any',
          '* >> scalar' => 'overload_any_addto_scalar',
      )
  };
  
  sub get_overload_method {
      my ($self, $arg1, $arg2, $swap, $operator) = @_;
      if ($swap) {
          $operator = $op_swap->{$operator} || $operator;
      }
      my $arg1_type = $self->get_argument_type($arg1);
      my $table1 = { $arg1->overload_table };
  
      if ($operator =~ /\{\}$/) {
          my $key = "$operator $arg1_type";
          return $table1->{$key} || $self->overload_undefined($key);
      }
  
      my $arg2_type = $self->get_argument_type($arg2);
      my @table2 = UNIVERSAL::isa($arg2, "IO::All")
      ? ($arg2->overload_table)
      : ();
      my $table = { %$table1, @table2 };
  
      my @keys = (
          "$arg1_type $operator $arg2_type",
          "* $operator $arg2_type",
      );
      push @keys, "$arg1_type $operator *", "* $operator *"
        unless $arg2_type =~ /^(scalar|array|hash|code|ref)$/;
  
      for (@keys) {
          return $table->{$_}
            if defined $table->{$_};
      }
  
      return $self->overload_undefined($keys[0]);
  }
  
  sub get_argument_type {
      my $self = shift;
      my $argument = shift;
      my $ref = ref($argument);
      return 'scalar' unless $ref;
      return 'code' if $ref eq 'CODE';
      return 'array' if $ref eq 'ARRAY';
      return 'hash' if $ref eq 'HASH';
      return 'ref' unless $argument->isa('IO::All');
      $argument->file
        if defined $argument->pathname and not $argument->type;
      return $argument->type || 'unknown';
  }
  
  sub overload_stringify {
      my $self = shift;
      my $name = $self->pathname;
      return defined($name) ? $name : overload::StrVal($self);
  }
  
  sub overload_undefined {
      my $self = shift;
      require Carp;
      my $key = shift;
      Carp::carp "Undefined behavior for overloaded IO::All operation: '$key'"
        if $^W;
      return 'overload_noop';
  }
  
  sub overload_noop {
      my $self = shift;
      return;
  }
  
  sub overload_any_addfrom_any {
      $_[1]->append($_[2]->all);
      $_[1];
  }
  
  sub overload_any_addto_any {
      $_[2]->append($_[1]->all);
      $_[2];
  }
  
  sub overload_any_from_any {
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]->all);
      $_[1];
  }
  
  sub overload_any_to_any {
      $_[2]->close if $_[2]->is_file and $_[2]->is_open;
      $_[2]->print($_[1]->all);
      $_[2];
  }
  
  sub overload_any_to_scalar {
      $_[2] = $_[1]->all;
  }
  
  sub overload_any_addto_scalar {
      $_[2] .= $_[1]->all;
      $_[2];
  }
  
  sub overload_scalar_addto_any {
      $_[1]->append($_[2]);
      $_[1];
  }
  
  sub overload_scalar_to_any {
      local $\;
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]);
      $_[1];
  }
  
  #===============================================================================
  # Private Accessors
  #===============================================================================
  field 'package';
  field _strict => undef;
  field _layers => [];
  field _handle => undef;
  
  #===============================================================================
  # Public Accessors
  #===============================================================================
  field constructor => undef;
  chain block_size => 1024;
  chain errors => undef;
  field io_handle => undef;
  field is_open => 0;
  chain mode => undef;
  chain name => undef;
  chain perms => undef;
  chain separator => $/;
  field type => '';
  field _partial_spec_class => undef;
  
  sub _spec_class {
     my $self = shift;
  
     my $ret = 'File::Spec';
     if (my $partial = $self->_partial_spec_class(@_)) {
        $ret .= '::' . $partial;
        eval "require $ret";
     }
  
     return $ret
  }
  
  sub pathname {my $self = shift; $self->name(@_) }
  
  #===============================================================================
  # Chainable option methods (write only)
  #===============================================================================
  option 'assert';
  option 'autoclose' => 1;
  option 'backwards';
  option 'chomp';
  option 'confess';
  option 'lock';
  option 'rdonly';
  option 'rdwr';
  option 'strict';
  
  #===============================================================================
  # IO::Handle proxy methods
  #===============================================================================
  proxy 'autoflush';
  proxy 'eof';
  proxy 'fileno';
  proxy 'stat';
  proxy 'tell';
  proxy 'truncate';
  
  #===============================================================================
  # IO::Handle proxy methods that open the handle if needed
  #===============================================================================
  proxy_open print => '>';
  proxy_open printf => '>';
  proxy_open sysread => O_RDONLY;
  proxy_open syswrite => O_CREAT | O_WRONLY;
  proxy_open seek => $^O eq 'MSWin32' ? '<' : '+<';
  proxy_open 'getc';
  
  #===============================================================================
  # Tie Interface
  #===============================================================================
  sub tie {
      my $self = shift;
      tie *$self, $self;
      return $self;
  }
  
  sub TIEHANDLE {
      return $_[0] if ref $_[0];
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->init(@_);
  }
  
  sub READLINE {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub DESTROY {
      my $self = shift;
      no warnings;
      unless ( $] < 5.008 ) {
          untie *$self if tied *$self;
      }
      $self->close if $self->is_open;
  }
  
  sub BINMODE {
      my $self = shift;
      CORE::binmode *$self->io_handle;
  }
  
  {
      no warnings;
      *GETC   = \&getc;
      *PRINT  = \&print;
      *PRINTF = \&printf;
      *READ   = \&read;
      *WRITE  = \&write;
      *SEEK   = \&seek;
      *TELL   = \&getpos;
      *EOF    = \&eof;
      *CLOSE  = \&close;
      *FILENO = \&fileno;
  }
  
  #===============================================================================
  # File::Spec Interface
  #===============================================================================
  sub canonpath {my $self = shift;
     eval { Cwd::abs_path($self->pathname); 0 } ||
        File::Spec->canonpath($self->pathname)
  }
  
  sub catdir {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->dir(File::Spec->catdir(@args));
  }
  sub catfile {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->file(File::Spec->catfile(@args));
  }
  sub join {my $self = shift; $self->catfile(@_) }
  sub curdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->curdir);
  }
  sub devnull {
      my $self = shift;
      $self->constructor->()->file(File::Spec->devnull);
  }
  sub rootdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->rootdir);
  }
  sub tmpdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->tmpdir);
  }
  sub updir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->updir);
  }
  sub case_tolerant {
      my $self = shift;
      File::Spec->case_tolerant;
  }
  sub is_absolute {
      my $self = shift;
      File::Spec->file_name_is_absolute($self->pathname);
  }
  sub path {
      my $self = shift;
      map { $self->constructor->()->dir($_) } File::Spec->path;
  }
  sub splitpath {
      my $self = shift;
      File::Spec->splitpath($self->pathname);
  }
  sub splitdir {
      my $self = shift;
      File::Spec->splitdir($self->pathname);
  }
  sub catpath {
      my $self = shift;
      $self->constructor->(File::Spec->catpath(@_));
  }
  sub abs2rel {
      my $self = shift;
      File::Spec->abs2rel($self->pathname, @_);
  }
  sub rel2abs {
      my $self = shift;
      File::Spec->rel2abs($self->pathname, @_);
  }
  
  #===============================================================================
  # Public IO Action Methods
  #===============================================================================
  sub absolute {
      my $self = shift;
      $self->pathname(File::Spec->rel2abs($self->pathname))
        unless $self->is_absolute;
      $self->is_absolute(1);
      return $self;
  }
  
  sub all {
      my $self = shift;
      $self->assert_open('<');
      local $/;
      my $all = $self->io_handle->getline;
      $self->error_check;
      $self->_autoclose && $self->close;
      return $all;
  }
  
  sub append {
      my $self = shift;
      $self->assert_open('>>');
      $self->print(@_);
  }
  
  sub appendln {
      my $self = shift;
      $self->assert_open('>>');
      $self->println(@_);
  }
  
  sub binary {
      my $self = shift;
      CORE::binmode($self->io_handle) if $self->is_open;
      push @{$self->_layers}, ":raw";
      return $self;
  }
  
  sub binmode {
      my $self = shift;
      my $layer = shift;
      $self->_sane_binmode($layer) if $self->is_open;
      push @{$self->_layers}, $layer;
      return $self;
  }
  
  sub _sane_binmode {
      my ($self, $layer) = @_;
      $layer
      ? CORE::binmode($self->io_handle, $layer)
      : CORE::binmode($self->io_handle);
  }
  
  sub buffer {
      my $self = shift;
      if (not @_) {
          *$self->{buffer} = do {my $x = ''; \ $x}
            unless exists *$self->{buffer};
          return *$self->{buffer};
      }
      my $buffer_ref = ref($_[0]) ? $_[0] : \ $_[0];
      $$buffer_ref = '' unless defined $$buffer_ref;
      *$self->{buffer} = $buffer_ref;
      return $self;
  }
  
  sub clear {
      my $self = shift;
      my $buffer = *$self->{buffer};
      $$buffer = '';
      return $self;
  }
  
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->io_handle(undef);
      $self->mode(undef);
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $message =
        "Can't call empty on an object that is neither file nor directory";
      $self->throw($message);
  }
  
  sub exists {my $self = shift; -e $self->pathname }
  
  sub getline {
      my $self = shift;
      return $self->getline_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my $line;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          $line = $self->io_handle->getline;
          chomp($line) if $self->_chomp and defined $line;
      }
      $self->error_check;
      return $line if defined $line;
      $self->close if $self->_autoclose;
      return undef;
  }
  
  sub getlines {
      my $self = shift;
      return $self->getlines_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my @lines;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          @lines = $self->io_handle->getlines;
          if ($self->_chomp) {
              chomp for @lines;
          }
      }
      $self->error_check;
      return @lines if @lines;
      $self->close if $self->_autoclose;
      return ();
  }
  
  sub is_dir {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Dir') }
  sub is_dbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::DBM') }
  sub is_file {my $self = shift; UNIVERSAL::isa($self, 'IO::All::File') }
  sub is_link {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Link') }
  sub is_mldbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::MLDBM') }
  sub is_socket {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Socket') }
  sub is_stdio {my $self = shift; UNIVERSAL::isa($self, 'IO::All::STDIO') }
  sub is_string {my $self = shift; UNIVERSAL::isa($self, 'IO::All::String') }
  sub is_temp {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Temp') }
  
  sub length {
      my $self = shift;
      length(${$self->buffer});
  }
  
  sub open {
      my $self = shift;
      return $self if $self->is_open;
      $self->is_open(1);
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args;
      unless ($self->is_dir) {
          push @args, $self->mode;
          push @args, $self->perms if defined $self->perms;
      }
      if (defined $self->pathname and not $self->type) {
          $self->file;
          return $self->open(@args);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_binmode;
  }
  
  sub println {
      my $self = shift;
      $self->print(map {/\n\z/ ? ($_) : ($_, "\n")} @_);
  }
  
  sub read {
      my $self = shift;
      $self->assert_open('<');
      my $length = (@_ or $self->type eq 'dir')
      ? $self->io_handle->read(@_)
      : $self->io_handle->read(
          ${$self->buffer},
          $self->block_size,
          $self->length,
      );
      $self->error_check;
      return $length || $self->_autoclose && $self->close && 0;
  }
  
  {
      no warnings;
      *readline = \&getline;
  }
  
  # deprecated
  sub scalar {
      my $self = shift;
      $self->all(@_);
  }
  
  sub slurp {
      my $self = shift;
      my $slurp = $self->all;
      return $slurp unless wantarray;
      my $separator = $self->separator;
      if ($self->_chomp) {
          local $/ = $separator;
          map {chomp; $_} split /(?<=\Q$separator\E)/, $slurp;
      }
      else {
          split /(?<=\Q$separator\E)/, $slurp;
      }
  }
  
  sub utf8 {
      my $self = shift;
      if ($] < 5.008) {
          die "IO::All -utf8 not supported on Perl older than 5.8";
      }
      $self->encoding('UTF-8');
      return $self;
  }
  
  sub _has_utf8 {
      grep { $_ eq ':encoding(UTF-8)' } @{shift->_layers}
  }
  
  sub encoding {
      my $self = shift;
      my $encoding = shift;
      if ($] < 5.008) {
          die "IO::All -encoding not supported on Perl older than 5.8";
      }
      die "No valid encoding string sent" if !$encoding;
      $self->_set_encoding($encoding) if $self->is_open and $encoding;
      push @{$self->_layers}, ":encoding($encoding)";
      return $self;
  }
  
  sub _set_encoding {
      my ($self, $encoding) = @_;
      return CORE::binmode($self->io_handle, ":encoding($encoding)");
  }
  
  sub write {
      my $self = shift;
      $self->assert_open('>');
      my $length = @_
      ? $self->io_handle->write(@_)
      : $self->io_handle->write(${$self->buffer}, $self->length);
      $self->error_check;
      $self->clear unless @_;
      return $length;
  }
  
  #===============================================================================
  # Implementation methods. Subclassable.
  #===============================================================================
  sub throw {
      my $self = shift;
      require Carp;
      ;
      return &{$self->errors}(@_)
        if $self->errors;
      return Carp::confess(@_)
        if $self->_confess;
      return Carp::croak(@_);
  }
  
  #===============================================================================
  # Private instance methods
  #===============================================================================
  sub assert_dirpath {
      my $self = shift;
      my $dir_name = shift;
      return $dir_name if ((! CORE::length($dir_name)) or
        -d $dir_name or
        CORE::mkdir($dir_name, $self->perms || 0755) or
        do {
            require File::Path;
            File::Path::mkpath($dir_name, 0, $self->perms || 0755 );
        } or
        $self->throw("Can't make $dir_name"));
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->file unless $self->type;
      return $self->open(@_);
  }
  
  sub error_check {
      my $self = shift;
      return unless $self->io_handle->can('error');
      return unless $self->io_handle->error;
      $self->throw($!);
  }
  
  sub copy {
      my $self = shift;
      my $copy;
      for (keys %{*$self}) {
          $copy->{$_} = *$self->{$_};
      }
      $copy->{io_handle} = 'defined'
        if defined $copy->{io_handle};
      return $copy;
  }
  
  sub set_binmode {
      my $self = shift;
      $self->_sane_binmode($_) for @{$self->_layers};
      return $self;
  }
  
  #===============================================================================
  # Stat Methods
  #===============================================================================
  BEGIN {
      no strict 'refs';
      my @stat_fields = qw(
          device inode modes nlink uid gid device_id size atime mtime
          ctime blksize blocks
      );
      foreach my $stat_field_idx (0 .. $#stat_fields)
      {
          my $idx = $stat_field_idx;
          my $name = $stat_fields[$idx];
  
          *$name = sub {
              my $self = shift;
              return (stat($self->io_handle || $self->pathname))[$idx];
          };
      }
  }
  
IO_ALL

$fatpacked{"IO/All/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_BASE';
  package IO::All::Base;
  $IO::All::Base::VERSION = '0.65';
  use strict;
  use warnings;
  use Fcntl;
  
  sub import {
      my $class = shift;
      my $flag = $_[0] || '';
      my $package = caller;
      no strict 'refs';
      if ($flag eq '-base') {
          push @{$package . "::ISA"}, $class;
          *{$package . "::$_"} = \&$_
            for qw'field const option chain proxy proxy_open';
      }
      elsif ($flag eq -mixin) {
          mixin_import(scalar(caller(0)), $class, @_);
      }
      else {
          my @flags = @_;
          for my $export (@{$class . '::EXPORT'}) {
              *{$package . "::$export"} = $export eq 'io'
              ? $class->generate_constructor(@flags)
              : \&{$class . "::$export"};
          }
      }
  }
  
  sub generate_constructor {
      my $class = shift;
      my (@flags, %flags, $key);
      for (@_) {
          if (s/^-//) {
              push @flags, $_;
              $flags{$_} = 1;
              $key = $_;
          }
          else {
              $flags{$key} = $_ if $key;
          }
      }
      my $constructor;
      $constructor = sub {
          my $self = $class->new(@_);
          for (@flags) {
              $self->$_($flags{$_});
          }
          $self->constructor($constructor);
          return $self;
      }
  }
  
  sub _init {
      my $self = shift;
      $self->io_handle(undef);
      $self->is_open(0);
      return $self;
  }
  
  #===============================================================================
  # Closure generating functions
  #===============================================================================
  sub option {
      my $package = caller;
      my ($field, $default) = @_;
      $default ||= 0;
      field("_$field", $default);
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            *$self->{"_$field"} = @_ ? shift(@_) : 1;
            return $self;
        };
  }
  
  sub chain {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            if (@_) {
                *$self->{$field} = shift;
                return $self;
            }
            return $default unless exists *$self->{$field};
            return *$self->{$field};
        };
  }
  
  sub field {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            unless (exists *$self->{$field}) {
                *$self->{$field} =
                  ref($default) eq 'ARRAY' ? [] :
                  ref($default) eq 'HASH' ? {} :
                  $default;
            }
            return *$self->{$field} unless @_;
            *$self->{$field} = shift;
        };
  }
  
  sub const {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} = sub { $default };
  }
  
  sub proxy {
      my $package = caller;
      my ($proxy) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      *{"${package}::$proxy"} =
        sub {
            my $self = shift;
            my @return = $self->io_handle->$proxy(@_);
            $self->error_check;
            wantarray ? @return : $return[0];
        };
  }
  
  sub proxy_open {
      my $package = caller;
      my ($proxy, @args) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      my $method = sub {
          my $self = shift;
          $self->assert_open(@args);
          my @return = $self->io_handle->$proxy(@_);
          $self->error_check;
          wantarray ? @return : $return[0];
      };
      *{"$package\::$proxy"} =
      (@args and $args[0] eq '>') ?
      sub {
          my $self = shift;
          $self->$method(@_);
          return $self;
      }
      : $method;
  }
  
  sub mixin_import {
      my $target_class = shift;
      $target_class = caller(0)
        if $target_class eq 'mixin';
      my $mixin_class = shift
        or die "Nothing to mixin";
      eval "require $mixin_class";
      my $pseudo_class = CORE::join '-', $target_class, $mixin_class;
      my %methods = mixin_methods($mixin_class);
      no strict 'refs';
      no warnings;
      @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
      @{"$target_class\::ISA"} = ($pseudo_class);
      for (keys %methods) {
          *{"$pseudo_class\::$_"} = $methods{$_};
      }
  }
  
  sub mixin_methods {
      my $mixin_class = shift;
      no strict 'refs';
      my %methods = all_methods($mixin_class);
      map {
          $methods{$_}
            ? ($_, \ &{"$methods{$_}\::$_"})
            : ($_, \ &{"$mixin_class\::$_"})
      } (keys %methods);
  }
  
  sub all_methods {
      no strict 'refs';
      my $class = shift;
      my %methods = map {
          ($_, $class)
      } grep {
          defined &{"$class\::$_"} and not /^_/
      } keys %{"$class\::"};
      return (%methods);
  }
  
  1;
IO_ALL_BASE

$fatpacked{"IO/All/DBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DBM';
  package IO::All::DBM;
  $IO::All::DBM::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  use Fcntl;
  
  field _dbm_list => [];
  field '_dbm_class';
  field _dbm_extra => [];
  
  sub dbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_dbm_list([@_]);
      return $self;
  }
  
  sub assert_open {
      my $self = shift;
      return $self->tied_file
        if $self->tied_file;
      $self->open;
  }
  
  sub assert_filepath {
      my $self = shift;
      $self->SUPER::assert_filepath(@_);
      if ($self->_rdonly and not -e $self->pathname) {
          my $rdwr = $self->_rdwr;
          $self->assert(0)->rdwr(1)->rdonly(0)->open;
          $self->close;
          $self->assert(1)->rdwr($rdwr)->rdonly(1);
      }
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      return $self->tied_file if $self->tied_file;
      $self->assert_filepath if $self->_assert;
      my $dbm_list = $self->_dbm_list;
      my @dbm_list = @$dbm_list ? @$dbm_list :
        (qw(DB_File GDBM_File NDBM_File ODBM_File SDBM_File));
      my $dbm_class;
      for my $module (@dbm_list) {
          (my $file = "$module.pm") =~ s{::}{/}g;
          if (defined $INC{$file} || eval "eval 'use $module; 1'") {
              $self->_dbm_class($module);
              last;
          }
      }
      $self->throw("No module available for IO::All DBM operation")
        unless defined $self->_dbm_class;
      my $mode = $self->_rdonly ? O_RDONLY : O_RDWR;
      if ($self->_dbm_class eq 'DB_File::Lock') {
          $self->_dbm_class->import;
          my $type = eval '$DB_HASH'; die $@ if $@;
          # XXX Not sure about this warning
          warn "Using DB_File::Lock in IO::All without the rdonly or rdwr method\n"
            if not ($self->_rdwr or $self->_rdonly);
          my $flag = $self->_rdwr ? 'write' : 'read';
          $mode = $self->_rdwr ? O_RDWR : O_RDONLY;
          $self->_dbm_extra([$type, $flag]);
      }
      $mode |= O_CREAT if $mode & O_RDWR;
      $self->mode($mode);
      $self->perms(0666) unless defined $self->perms;
      return $self->tie_dbm;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $hash;
      my $filename = $self->name;
      my $db = tie %$hash, $self->_dbm_class, $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as DBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  sub add_utf8_dbm_filter {
      my $self = shift;
      my $db = shift;
      $db->filter_store_key(sub { utf8::encode($_) });
      $db->filter_store_value(sub { utf8::encode($_) });
      $db->filter_fetch_key(sub { utf8::decode($_) });
      $db->filter_fetch_value(sub { utf8::decode($_) });
  }
  
  1;
IO_ALL_DBM

$fatpacked{"IO/All/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DIR';
  package IO::All::Dir;
  $IO::All::Dir::VERSION = '0.65';
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::Dir;
  
  #===============================================================================
  const type => 'dir';
  option 'sort' => 1;
  chain filter => undef;
  option 'deep';
  field 'chdir_from';
  
  #===============================================================================
  sub dir {
      my $self = shift;
      my $had_prev = blessed($self) && $self->pathname;
  
      bless $self, __PACKAGE__ unless $had_prev;
      if (@_ && @_ > 1 || @_ && $had_prev) {
         $self->name(
             $self->_spec_class->catdir(
                 ($self->pathname ? ($self->pathname) : () ),
                 @_,
             )
         )
      } elsif (@_) {
         $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub dir_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_dirpath($self->pathname)
        if $self->pathname and $self->_assert;
      my $handle = IO::Dir->new;
      $self->io_handle($handle);
      $handle->open($self->pathname)
        or $self->throw($self->open_msg);
      return $self;
  }
  
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      return qq{Can't open directory$name:\n$!};
  }
  
  sub exists { -d shift->pathname }
  
  #===============================================================================
  sub All {
      my $self = shift;
      $self->all(0);
  }
  
  sub all {
      my $self = shift;
      my $depth = @_ ? shift(@_) : $self->_deep ? 0 : 1;
      my $first = not @_;
      my @all;
      while (my $io = $self->next) {
          push @all, $io;
          push(@all, $io->all($depth - 1, 1))
            if $depth != 1 and $io->is_dir;
      }
      @all = grep {&{$self->filter}} @all
        if $self->filter;
      return @all unless $first and $self->_sort;
      return sort {$a->pathname cmp $b->pathname} @all;
  }
  
  sub All_Dirs {
      my $self = shift;
      $self->all_dirs(0);
  }
  
  sub all_dirs {
      my $self = shift;
      grep {$_->is_dir} $self->all(@_);
  }
  
  sub All_Files {
      my $self = shift;
      $self->all_files(0);
  }
  
  sub all_files {
      my $self = shift;
      grep {$_->is_file} $self->all(@_);
  }
  
  sub All_Links {
   my $self = shift;
   $self->all_links(0);
  }
  
  sub all_links {
      my $self = shift;
      grep {$_->is_link} $self->all(@_);
  }
  
  sub chdir {
      my $self = shift;
      require Cwd;
      $self->chdir_from(Cwd::cwd());
      CORE::chdir($self->pathname);
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $dh;
      opendir($dh, $self->pathname) or die;
      while (my $dir = readdir($dh)) {
         return 0 unless $dir =~ /^\.{1,2}$/;
      }
      return 1;
  }
  
  sub mkdir {
      my $self = shift;
      defined($self->perms)
      ? (CORE::mkdir($self->pathname, $self->perms) or die "mkdir failed: $!")
      : (CORE::mkdir($self->pathname) or die "mkdir failed: $!");
      return $self;
  }
  
  sub mkpath {
      my $self = shift;
      require File::Path;
      File::Path::mkpath($self->pathname, @_);
      return $self;
  }
  
  sub file {
      my ($self, @rest) = @_;
  
      return $self->constructor->()->file($self->pathname, @rest)
  }
  
  sub next {
      my $self = shift;
      $self->assert_open;
      my $name = $self->readdir;
      return unless defined $name;
      my $io = $self->constructor->(File::Spec->catfile($self->pathname, $name));
      $io->absolute if $self->is_absolute;
      return $io;
  }
  
  sub readdir {
      my $self = shift;
      $self->assert_open;
      if (wantarray) {
          my @return = grep {
              not /^\.{1,2}$/
          } $self->io_handle->read;
          $self->close;
          return @return;
      }
      my $name = '.';
      while ($name =~ /^\.{1,2}$/) {
          $name = $self->io_handle->read;
          unless (defined $name) {
              $self->close;
              return;
          }
      }
      return $name;
  }
  
  sub rmdir {
      my $self = shift;
      rmdir $self->pathname;
  }
  
  sub rmtree {
      my $self = shift;
      require File::Path;
      File::Path::rmtree($self->pathname, @_);
  }
  
  sub glob {
     my ($self, @rest) = @_;
  
     map {;
        my $ret = $self->constructor->($_);
        $ret->absolute if $self->is_absolute;
        $ret
     } glob $self->_spec_class->catdir( $self->pathname, @rest );
  }
  
  sub DESTROY {
      my $self = shift;
      CORE::chdir($self->chdir_from)
        if $self->chdir_from;
        # $self->SUPER::DESTROY(@_);
  }
  
  #===============================================================================
  sub overload_table {
      (
          '${} dir' => 'overload_as_scalar',
          '@{} dir' => 'overload_as_array',
          '%{} dir' => 'overload_as_hash',
      )
  }
  
  sub overload_as_scalar {
      \ $_[1];
  }
  
  sub overload_as_array {
      [ $_[1]->all ];
  }
  
  sub overload_as_hash {
      +{
          map {
              (my $name = $_->pathname) =~ s/.*[\/\\]//;
              ($name, $_);
          } $_[1]->all
      };
  }
  
  1;
IO_ALL_DIR

$fatpacked{"IO/All/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILE';
  package IO::All::File;
  $IO::All::File::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::File;
  
  #===============================================================================
  const type => 'file';
  field tied_file => undef;
  
  #===============================================================================
  sub file {
      my $self = shift;
      bless $self, __PACKAGE__;
      # should we die here if $self->name is already set and there are args?
      if (@_ && @_ > 1) {
          $self->name( $self->_spec_class->catfile( @_ ) )
      } elsif (@_) {
          $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub file_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_filepath {
      my $self = shift;
      my $name = $self->pathname
        or return;
      my $directory;
      (undef, $directory) = File::Spec->splitpath($self->pathname);
      $self->assert_dirpath($directory);
  }
  
  sub assert_open_backwards {
      my $self = shift;
      return if $self->is_open;
      require File::ReadBackwards;
      my $file_name = $self->pathname;
      my $io_handle = File::ReadBackwards->new($file_name)
        or $self->throw("Can't open $file_name for backwards:\n$!");
      $self->io_handle($io_handle);
      $self->is_open(1);
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub assert_tied_file {
      my $self = shift;
      return $self->tied_file || do {
          eval {require Tie::File};
          $self->throw("Tie::File required for file array operations:\n$@")
            if $@;
          my $array_ref = do { my @array; \@array };
          my $name = $self->pathname;
          my @options = $self->_rdonly ? (mode => O_RDONLY) : ();
          push @options, (recsep => "\n");
          tie @$array_ref, 'Tie::File', $name, @options;
          $self->throw("Can't tie 'Tie::File' to '$name':\n$!")
            unless tied @$array_ref;
          $self->tied_file($array_ref);
      };
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_filepath if $self->_assert;
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args = ($self->mode);
      push @args, $self->perms if defined $self->perms;
      if (defined $self->pathname) {
          $self->io_handle(IO::File->new);
          $self->io_handle->open($self->pathname, @args)
            or $self->throw($self->open_msg);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_lock;
      $self->set_binmode;
  }
  
  sub exists { -f shift->pathname }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open file$name$direction:\n$!};
  }
  
  #===============================================================================
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->unlock;
      $self->io_handle(undef);
      $self->mode(undef);
      if (my $tied_file = $self->tied_file) {
          if (ref($tied_file) eq 'ARRAY') {
              untie @$tied_file;
          }
          else {
              untie %$tied_file;
          }
          $self->tied_file(undef);
          return 1;
      }
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      -z $self->pathname;
  }
  
  sub filepath {
      my $self = shift;
      my ($volume, $path) = $self->splitpath;
      return File::Spec->catpath($volume, $path, '');
  }
  
  sub getline_backwards {
      my $self = shift;
      $self->assert_open_backwards;
      return $self->io_handle->readline;
  }
  
  sub getlines_backwards {
      my $self = shift;
      my @lines;
      while (defined (my $line = $self->getline_backwards)) {
          push @lines, $line;
      }
      return @lines;
  }
  
  sub head {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
  
      LINES:
      while ($lines--) {
          if (defined (my $l = $self->getline)) {
              push @return, $l;
          }
          else {
              last LINES;
          }
      }
  
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub tail {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
      while ($lines--) {
          unshift @return, ($self->getline_backwards or last);
      }
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub touch {
      my $self = shift;
      return $self->SUPER::touch(@_)
        if -e $self->pathname;
      return $self if $self->is_open;
      my $mode = $self->mode;
      $self->mode('>>')->open->close;
      $self->mode($mode);
      return $self;
  }
  
  sub unlink {
      my $self = shift;
      unlink $self->pathname;
  }
  
  #===============================================================================
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          'file > file' => 'overload_file_to_file',
          'file < file' => 'overload_file_from_file',
          '${} file' => 'overload_file_as_scalar',
          '@{} file' => 'overload_file_as_array',
          '%{} file' => 'overload_file_as_dbm',
      )
  }
  
  sub overload_file_to_file {
      require File::Copy;
      File::Copy::copy($_[1]->pathname, $_[2]->pathname);
      $_[2];
  }
  
  sub overload_file_from_file {
      require File::Copy;
      File::Copy::copy($_[2]->pathname, $_[1]->pathname);
      $_[1];
  }
  
  sub overload_file_as_array {
      $_[1]->assert_tied_file;
  }
  
  sub overload_file_as_dbm {
      $_[1]->dbm
        unless $_[1]->isa('IO::All::DBM');
      $_[1]->assert_open;
  }
  
  sub overload_file_as_scalar {
      my $scalar = $_[1]->scalar;
      return \$scalar;
  }
  
  1;
IO_ALL_FILE

$fatpacked{"IO/All/Filesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILESYS';
  package IO::All::Filesys;
  $IO::All::Filesys::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::Base -base;
  use Fcntl qw(:flock);
  
  my %spec_map = (
      unix  => 'Unix',
      win32 => 'Win32',
      vms   => 'VMS',
      mac   => 'Mac',
      os2   => 'OS2',
  );
  sub os {
      my ($self, $type) = @_;
  
      my ($v, $d, $f) = $self->_spec_class->splitpath($self->name);
      my @d = $self->_spec_class->splitdir($d);
  
      $self->_spec_class($spec_map{$type});
  
      $self->name( $self->_spec_class->catfile( @d, $f ) );
  
      return $self
  }
  
  sub exists { my $self = shift; -e $self->name }
  
  sub filename {
      my $self = shift;
      my $filename;
      (undef, undef, $filename) = $self->splitpath;
      return $filename;
  }
  
  sub ext {
     my $self = shift;
  
     return $1 if $self->filename =~ m/\.([^\.]+)$/
  }
  {
      no warnings 'once';
      *extension = \&ext;
  }
  
  sub mimetype {
     require File::MimeInfo;
     return File::MimeInfo::mimetype($_[0]->filename)
  }
  
  sub is_absolute {
      my $self = shift;
      return *$self->{is_absolute} = shift if @_;
      return *$self->{is_absolute}
        if defined *$self->{is_absolute};
      *$self->{is_absolute} = IO::All::is_absolute($self) ? 1 : 0;
  }
  
  sub is_executable { my $self = shift; -x $self->name }
  sub is_readable { my $self = shift; -r $self->name }
  sub is_writable { my $self = shift; -w $self->name }
  {
      no warnings 'once';
      *is_writeable = \&is_writable;
  }
  
  sub pathname {
      my $self = shift;
      return *$self->{pathname} = shift if @_;
      return *$self->{pathname} if defined *$self->{pathname};
      return $self->name;
  }
  
  sub relative {
      my $self = shift;
      $self->pathname(File::Spec->abs2rel($self->pathname))
        if $self->is_absolute;
      $self->is_absolute(0);
      return $self;
  }
  
  sub rename {
      my $self = shift;
      my $new = shift;
      rename($self->name, "$new")
        ? UNIVERSAL::isa($new, 'IO::All')
          ? $new
          : $self->constructor->($new)
        : undef;
  }
  
  sub set_lock {
      my $self = shift;
      return unless $self->_lock;
      my $io_handle = $self->io_handle;
      my $flag = $self->mode =~ /^>>?$/
      ? LOCK_EX
      : LOCK_SH;
      flock $io_handle, $flag;
  }
  
  sub stat {
      my $self = shift;
      return IO::All::stat($self, @_)
        if $self->is_open;
        CORE::stat($self->pathname);
  }
  
  sub touch {
      my $self = shift;
      $self->utime;
  }
  
  sub unlock {
      my $self = shift;
      flock $self->io_handle, LOCK_UN
        if $self->_lock;
  }
  
  sub utime {
      my $self = shift;
      my $atime = shift;
      my $mtime = shift;
      $atime = time unless defined $atime;
      $mtime = $atime unless defined $mtime;
      utime($atime, $mtime, $self->name);
      return $self;
  }
  
  1;
IO_ALL_FILESYS

$fatpacked{"IO/All/Link.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_LINK';
  package IO::All::Link;
  $IO::All::Link::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  
  const type => 'link';
  
  sub link {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      $self->_init;
  }
  
  sub readlink {
      my $self = shift;
      $self->constructor->(CORE::readlink($self->name));
  }
  
  sub symlink {
      my $self = shift;
      my $target = shift;
      $self->assert_filepath if $self->_assert;
      CORE::symlink($target, $self->pathname);
  }
  
  sub AUTOLOAD {
      my $self = shift;
      our $AUTOLOAD;
      (my $method = $AUTOLOAD) =~ s/.*:://;
      my $target = $self->target;
      unless ($target) {
          $self->throw("Can't call $method on symlink");
          return;
      }
      $target->$method(@_);
  }
  
  sub target {
      my $self = shift;
      return *$self->{target} if *$self->{target};
      my %seen;
      my $link = $self;
      my $new;
      while ($new = $link->readlink) {
          my $type = $new->type or return;
          last if $type eq 'file';
          last if $type eq 'dir';
          return unless $type eq 'link';
          return if $seen{$new->name}++;
          $link = $new;
      }
      *$self->{target} = $new;
  }
  
  sub exists { -l shift->pathname }
  
  1;
IO_ALL_LINK

$fatpacked{"IO/All/MLDBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_MLDBM';
  package IO::All::MLDBM;
  $IO::All::MLDBM::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::DBM -base;
  
  field _serializer => 'Data::Dumper';
  
  sub mldbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      my ($serializer) = grep { /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_serializer($serializer) if defined $serializer;
      my @dbm_list = grep { not /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_dbm_list([@dbm_list]);
      return $self;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $filename = $self->name;
      my $dbm_class = $self->_dbm_class;
      my $serializer = $self->_serializer;
      eval "use MLDBM qw($dbm_class $serializer)";
      $self->throw("Can't open '$filename' as MLDBM:\n$@") if $@;
      my $hash;
      my $db = tie %$hash, 'MLDBM', $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as MLDBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  1;
IO_ALL_MLDBM

$fatpacked{"IO/All/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_PIPE';
  package IO::All::Pipe;
  $IO::All::Pipe::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'pipe';
  
  sub pipe {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      require IO::Handle;
      $self->io_handle(IO::Handle->new)
        unless defined $self->io_handle;
      my $command = $self->name;
      $command =~ s/(^\||\|$)//;
      my $mode = shift || $self->mode || '<';
      my $pipe_mode =
        $mode eq '>' ? '|-' :
        $mode eq '<' ? '-|' :
        $self->throw("Invalid usage mode '$mode' for pipe");
      CORE::open($self->io_handle, $pipe_mode, $command);
      $self->set_binmode;
  }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->name
        ? " '" . $self->name . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open pipe$name$direction:\n$!};
  }
  
  1;
IO_ALL_PIPE

$fatpacked{"IO/All/STDIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STDIO';
  package IO::All::STDIO;
  $IO::All::STDIO::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'stdio';
  
  sub stdio {
      my $self = shift;
      bless $self, __PACKAGE__;
      return $self->_init;
  }
  
  sub stdin {
      my $self = shift;
      $self->open('<');
      return $self;
  }
  
  sub stdout {
      my $self = shift;
      $self->open('>');
      return $self;
  }
  
  sub stderr {
      my $self = shift;
      $self->open_stderr;
      return $self;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      my $mode = shift || $self->mode || '<';
      my $fileno = $mode eq '>'
      ? fileno(STDOUT)
      : fileno(STDIN);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen($fileno, $mode);
      $self->set_binmode;
  }
  
  sub open_stderr {
      my $self = shift;
      $self->is_open(1);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen(fileno(STDERR), '>') ? $self : 0;
  }
  
  # XXX Add overload support
  
  1;
IO_ALL_STDIO

$fatpacked{"IO/All/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_SOCKET';
  package IO::All::Socket;
  $IO::All::Socket::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  use IO::Socket;
  
  const type => 'socket';
  field _listen => undef;
  option 'fork';
  const domain_default => 'localhost';
  chain domain => undef;
  chain port => undef;
  proxy_open 'recv';
  proxy_open 'send';
  
  sub socket {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub socket_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  sub accept {
      my $self = shift;
      use POSIX ":sys_wait_h";
      sub REAPER {
          while (waitpid(-1, WNOHANG) > 0) {}
          $SIG{CHLD} = \&REAPER;
      }
      local $SIG{CHLD};
      $self->_listen(1);
      $self->assert_open;
      my $server = $self->io_handle;
      my $socket;
      while (1) {
          $socket = $server->accept;
          last unless $self->_fork;
          next unless defined $socket;
          $SIG{CHLD} = \&REAPER;
          my $pid = CORE::fork;
          $self->throw("Unable to fork for IO::All::accept")
            unless defined $pid;
          last unless $pid;
          close $socket;
          undef $socket;
      }
      close $server if $self->_fork;
      my $io = ref($self)->new->socket_handle($socket);
      $io->io_handle($socket);
      $io->is_open(1);
      return $io;
  }
  
  sub shutdown {
      my $self = shift;
      my $how = @_ ? shift : 2;
      my $handle = $self->io_handle;
      $handle->shutdown(2)
        if defined $handle;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      return if $self->is_open;
      $self->is_open(1);
      $self->get_socket_domain_port;
      my @args = $self->_listen
      ? (
          LocalAddr => $self->domain,
          LocalPort => $self->port,
          Proto => 'tcp',
          Listen => 1,
          Reuse => 1,
      )
      : (
          PeerAddr => $self->domain,
          PeerPort => $self->port,
          Proto => 'tcp',
      );
      my $socket = IO::Socket::INET->new(@args)
        or $self->throw("Can't open socket");
      $self->io_handle($socket);
      $self->set_binmode;
  }
  
  sub get_socket_domain_port {
      my $self = shift;
      my ($domain, $port);
      ($domain, $port) = split /:/, $self->name
        if defined $self->name;
      $self->domain($domain) unless defined $self->domain;
      $self->domain($self->domain_default) unless $self->domain;
      $self->port($port) unless defined $self->port;
      return $self;
  }
  
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          '&{} socket' => 'overload_socket_as_code',
      )
  }
  
  sub overload_socket_as_code {
      my $self = shift;
      sub {
          my $coderef = shift;
          while ($self->is_open) {
              $_ = $self->getline;
              &$coderef($self);
          }
      }
  }
  
  sub overload_any_from_any {
      my $self = shift;
      $self->SUPER::overload_any_from_any(@_);
      $self->close;
  }
  
  sub overload_any_to_any {
      my $self = shift;
      $self->SUPER::overload_any_to_any(@_);
      $self->close;
  }
  
  1;
IO_ALL_SOCKET

$fatpacked{"IO/All/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STRING';
  package IO::All::String;
  $IO::All::String::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All -base;
  
  const type => 'string';
  
  
  sub string_ref {
     my ($self, $ref) = @_;
  
     no strict 'refs';
     *$self->{ref} = $ref if exists $_[1];
  
     return *$self->{ref}
  }
  
  sub string {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_init;
  }
  
  sub open {
      my $self = shift;
      my $str = '';
      my $ref = \$str;
      $self->string_ref($ref);
      open my $fh, '+<', $ref;
      $self->io_handle($fh);
      $self->set_binmode;
      $self->is_open(1);
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::String - String IO Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2005. Brian Ingerson. All rights reserved.
  
  Copyright (c) 2006-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_STRING

$fatpacked{"IO/All/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_TEMP';
  package IO::All::Temp;
  $IO::All::Temp::VERSION = '0.65';
  use strict;
  use warnings;
  use IO::All::File -base;
  
  sub temp {
      my $self = shift;
      bless $self, __PACKAGE__;
      my $temp_file = IO::File::new_tmpfile()
        or $self->throw("Can't create temporary file");
      $self->io_handle($temp_file);
      $self->error_check;
      $self->autoclose(0);
      $self->is_open(1);
      return $self;
  }
  
  1;
IO_ALL_TEMP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#Ask and find! Version 4.3 stable.
#2014 by Luke V. Franklin.

#modules
#-----------------------------------------------------------------------------

use strict;
use warnings;
use feature 'say';
use feature 'fc';
use IO::All;
use Cwd 'abs_path';
use File::Basename;
use POSIX;

#subroutines
#-----------------------------------------------------------------------------

#shows about message
sub about{
   
   say "\n\tAsk and find! Version 4.3 - new functions added!";
   say "\t2014 by Luke V. Franklin.";
   
   say "\n\tkey:value - store pairs key/value.";
   say "\tks <key> - search the keys in the current file.";
   say "\ths - histogram of the keys.";
   say "\te - edit the specified key.";
   say "\tcd - change the default dir.";
   say "\td - delete the specified key.";
   say "\tdf - delete the current file loaded.";
   say "\tl - load other keyword files.";
   say "\ta/h - show this message.";
   say "\tp - show current work directory.";
   say "\tls - show the quantity of lines of the file.";
   say "\tk - show all keys of the file.";
   say "\tv <pattern> - search for patterns in values.";
   say "\ts - sort the file alfabetically.";
   say "\tq/ex - exit the program.\n";
   say "\tHints, doubts and bugs: report to <lukevinc9\@gmail.com>\n";
   
   return 1;
}

#count lines of the file
sub count_lines
{
    my ($filename) = @_;

    open my $fh, '<', $filename;

    my $count = 0;
    while (my $l = <$fh>)
    {
        $count++;
    }

    close($fh);

    return $count;
}

#local variables and start
#-----------------------------------------------------------------------------

my $default;
my $dirfile;
my $dirdirfile;
if (-e "$ENV{PWD}/dirfile.txt"){
  
  $dirfile = io->file("$ENV{PWD}/dirfile.txt");
  
  while (my $line = $dirfile->chomp->getline()) {
    $line =~ s/~/$ENV{HOME}/;
    say $line;
    $default = $line;
    last;
    
  } 
  
  $dirdirfile = "$ENV{PWD}/dirfile.txt";

}

elsif (-e "dirfile.txt"){

  my $dir = io->file("dirfile.txt");
  
  while (my $line = $dirfile->chomp->getline()) {
    $line =~ s/~/$ENV{HOME}/;
    $default = $line;
    last;
    
  }
  
  $dirdirfile = "dirfile.txt";
  
}  
else{
  
print <<"CREATE";
	  Do you want create the file 'dirfile.txt' to store your default directory?
	  It will be created in $ENV{ PWD } (y/N): 
CREATE

  chomp( my $entry = <STDIN>);
             
  unless ( $entry eq 'y' ){
            
    say "\n\tAborting program...\n";  
    exit();
  }
  
  io->file("$ENV{PWD}/dirfile.txt")->utf8->print("$ENV{PWD}/keywords.txt"); 
  $default = "$ENV{PWD}/keywords.txt" ; 
  
  $dirdirfile = "$ENV{ PWD }/dirfile.txt";
  say "\n\tDefault directory file created successfully!\n";
  
}  

unless ( $default || (-e $default) || length($default) ){
 
  say "\n\tInvalid directory, check your dirfile.txt and check it for errors.\n";
  
  exit();
}

my $dir = $default;
$dir =~ s/~/$ENV{HOME}/g;

about();

#main loop
#------------------------------------------------------------------------------

MAIN:while ( 1 ) {
   
   my $dirname = $dir;
   $dirname =~ s/$ENV{ HOME }/~/;
       
   unless ( -e $dir){
   
print <<"CREATE";
	  
	  Do you want create 'keywords.txt' to store your data?
	  It will be created in $dirname. (y/N):
CREATE
        
         chomp( my $entry2 = <STDIN>);
             
         unless ( $entry2 eq 'y' ){
            
            say "\n\tAborting...\n";  
            last MAIN;
         }

         io->file($dir)->utf8->print("");
          
         say "\n\tFile created successfully: $dirname\n";  
         next MAIN;
   }
   
   my $file = io->file($dir);
                            
   print "Prompt\@$dirname: ";
   chomp( my $entry = <STDIN>);
   
   if($entry eq ''){
    
         say "\n\tError: blank key. Try another.\n";
         
         next MAIN;
  
   }
      
   my $count = @{[$entry =~ /:/g]};#count number of colons
    
   if ( $count > 1 ){
      say "\n\tError: more than one colon found! Try again!\n";
      
      next MAIN;
   }
   
   #keys menu
#------------------------------------------------------------------------------   
   if ($entry =~ /ks (.*)/) {
           
      say "";
      while (my $line = $file->chomp->getline()) {
         
         my @key = split ':', $line;
         if ($1){
            
            if ($key[0] =~ /\b\Q${1}\E/i){
            
               say "\t$key[0]";
               $count++;
            }
         }
      }
      say "\n\tKeys found: $count\n";      
      
      next MAIN;    
   }
   
   last MAIN if ($entry =~ /^(ex|q)$/);


  #histogram menu
#------------------------------------------------------------------------------     
   
   if ($entry eq 'hs') {
     
     my %hist;
     my @alfa = 'A' .. 'Z';
     my $total;
     while (my $line = $file->chomp->getline()) {
  
        my ($key, $value) = split ':', $line;
          
        my $initial = substr( $key, 0, 1 );
     
        foreach (@alfa){
     
          if ($key =~ m/^TO (.*)/){
            
            $hist{'Verbs'}++;
            last;
          }  
                    
          if ($initial eq $_){
           
             $hist{$_}++;
             $total++;
             last;  
          }
        }  
        
      }  
      my $sum = 0;
      my $count2 = 0;
      
      print "\n\t";
      foreach (sort keys %hist ){
       
        my $pc = ( $hist{$_} / $total ) * 30;
        
        $pc = ceil( $pc );
        
        $sum += $pc;
        print "$_: ", "*" x $pc, " ($pc) : "; 
        
        $count2++;
        
        if ($count2 > 3){
         print "\n\t";
         $count2 = 0;
        }
               
      }
      
      say "\n\n\tTotal: $sum\n";
      say "\tHint: sort the file to obtain better accuracy.\n";
      
      next MAIN;
   }   

   #edit menu
#------------------------------------------------------------------------------     
   if ($entry eq 'e') {
      print "\n\tWhich key do you want to edit? ";
      
      chomp( my $entry = <STDIN>) ;
          
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         if ($entry eq $word) {#if key is in keywords
            print "\n\tText for '$word': ";
            
            chomp( my $entry = <STDIN>);
                  
            $count = @{[$entry =~ /:/g]};#count number of colons
            
            if ($count) {
               say "\n\tError: colon found in text.\n";          
               
               next MAIN;
            }
            print "Are you sure do you want to edit this key? (y/N): ";
            
            chomp( my $yesno = <STDIN> );           
            
            unless ($yesno eq 'y'){
            
               say "\n\tKey edit canceled!\n";
               next MAIN;
            }
               
            $text = $entry;
            $count++;
         }
         chomp( $text );    
         $keyvalue{$word} = $text;
      }
              
      unless ($count){
      
         say "\n\tError: key for edition not found!\n";
         next 
      }
      io->file($dir)->utf8->print("");  
          
      foreach (sort keys %keyvalue){
         
         "$_:$keyvalue{ $_ }\n" >> io->file($dir);
      }
      say "\n\tKey updated successfully in $dirname!'\n";                
      
      next MAIN;   
   }

 #change dir menu
#------------------------------------------------------------------------------   
   if ($entry eq 'cd') {
     
      print "Which is the new default directory? ";
      
      chomp( my $entry2 = <STDIN>); 
      
      print "\n\tAre you sure do you want change the default dir? (y/N): "; 
      chomp( my $yesno = <STDIN>); 
      
      unless ( $yesno eq 'y' ){
        say "\n\tDirectory change canceled.\n";    
        
        next MAIN;
       
      }
      
      $entry2 =~ s/~/$ENV{ HOME }/g;
      
      unless (-e $entry2){
       say "\n\tError: invalid directory!\n";       
       
       next MAIN;  
      }
      
      $dir = $entry2;
      io->file($dirdirfile)->utf8->print($entry2); 
            
      
      say "\n\tDefault file changed successfully in $dirdirfile\n";
      next MAIN;   
   } 

   #load menu
#------------------------------------------------------------------------------   
   if ($entry eq 'l') {
      
      print "\n\tType the dir/file do you want to load your keys: ";
      chomp( my $entry = <STDIN>);
     
      my $safe = $dir;
      
      $dir = $entry;
      $dir =~ s/~/$ENV{ HOME }/;#understand ~ as homedir
      
      $dir = abs_path($dir) or die "$!";#add absolute path
      my $dirname = $dir;
      $dirname =~ s/$ENV{ HOME }/~/;
      
      if ( -d $dir ){
            say "\n\tError: $dirname is a directory!\n";
            
            $dir = $safe;
            next MAIN;
      }   
      
      unless ( -e $dir){
         my $basename = basename($dir);

print <<"CREATE"; 
         Do you want to create the file '$basename' to store your data?
         It will be created in $dirname (y/N): 
CREATE
           
         chomp( my $entry2 = <STDIN>);
          
         unless ( $entry2 eq 'y' ){
            
            say "\n\tProgram load canceled.\n";
              
            $dir = $safe;
            next MAIN;
         }
                    
         io->file($dir)->utf8->print(""); 
         say "\n\tFile created successfully: $dirname\n"; 
         
         next MAIN;
      }
      
      say "\n\t$dirname : ".count_lines($dir)." key(s) loaded!\n";
      
      next MAIN;      
   }
   
   #delete menu
#------------------------------------------------------------------------------   
   if ($entry eq 'd') {
      
      print "\n\tWhich key do you want to delete? ";
      chomp( my $entry = <STDIN>);
        
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         if ($entry =~ /\b$word\b/i) {#if key is in keywords
         
            print "\tAre you sure do you want to delete '$entry'? (y/N): ";
            
            chomp( my $entry = <STDIN>);
            
            if ($entry eq 'y'){
              say "\n\tKey '$word' deleted successfully!\n";
            }
            
            else{
               
               say "\n\tError: key '$word' not deleted!\n";
               next MAIN;
            }
                        
            $count++;
            next;
            
         }
         chomp( $text );    
         $keyvalue{ $word } = $text;
      }
              
      unless ($count){
      
         
         say "\n\tError: key doesn't exists!\n";
         next MAIN;
      }
           
      io->file($dir)->utf8->print("");  
         
      foreach (sort keys %keyvalue){
         
         "$_:$keyvalue{ $_ }\n" >> io->file( $dir );
      }
                     
      next MAIN;   
   }

   #delete file menu
#------------------------------------------------------------------------------   
   if ($entry eq 'df') {
     my $basename = basename($dir);
     print "\tAre you sure do you want to edit '$basename'? (y/N): ";
     
     chomp( my $entry = <STDIN> );
     
      unless ( $entry eq 'y' ){
            say "\n\tFile delete canceled.\n";
            next MAIN;
         }
         
     unlink $dir;
     
     say "\n\tFile '$basename' deleted successfully!\n";
     $dir = $default;    
          
     next MAIN;  
   }

   #about menu
#------------------------------------------------------------------------------   
   if ($entry =~ /^(a|h)$/) {
         
      about();
      
      next MAIN;  
   }

   #pwd menu
#------------------------------------------------------------------------------   
   if ($entry eq 'p') {
      say "\n\tYou are here: $ENV{PWD}\n";
      
      next MAIN;
   }
    
   #line counting menu
#------------------------------------------------------------------------------ 
    if ($entry eq 'ls') {
      
      say "\n\t".count_lines( $dir )." line(s) found in $dir\n";
      next MAIN;
   }
   
  #keywords menu
#------------------------------------------------------------------------------ 
    if ($entry eq 'k') {
      
      my $space = 0;
      while (my $line = $file->chomp->getline()) {
      
         my @keys = split ':', $line;
         
         if (length($keys[0]) > $space){
            
            $space = length($keys[0]);
         }
     }
      
      say "";
      while (my $line = $file->chomp->getline()) {
         my @keys = split ':', $line;
         
         my $size = $space - length($keys[0]) + 1;
         printf "\t%s%${size}s", $keys[0], "";   
         if ($count > 1){
            say "";
            $count = 0;
            next;
         }
         
         $count++;   
         
      }
           
      say "\n\n\t".count_lines($dir)." key(s) found in $dirname.\n";
            
      next MAIN;
   }   

#value menu
#------------------------------------------------------------------------------ 
    if ($entry =~ m/v (.*)/) {
  
       my $count = 0;
       
       print "\n";
       while (my $line = $file->chomp->getline()) {
  
          my ($key, $value) = split ':', $line;
          
          
          if ($value =~ m/$1/){
            
            say "\t$key:$value"; 
            $count++;
          }
      
       }
       
       say "\n\t$count key(s) found.\n";
      next MAIN;
    }
 
 #sort menu
#------------------------------------------------------------------------------ 
    if ($entry eq 's') {
      $file = io->file($dir);
      my %keyvalue;
      
      while (my $line = $file->chomp->getline()) {
      
         my ($word, $text) = split ':', $line;
         
         $keyvalue{ $word } = $text;
  
      }
      
      io->file($dir)->utf8->print("");
            
      foreach ( sort { fc($a) cmp fc($b)}keys %keyvalue){
         
         uc($_).":$keyvalue{ $_ }\n" >> io->file( $dir );
       
      }
      say "\n\tKeys sorted in '$dirname' successfully!\n";                
      
      next MAIN;
       
    }
   #search and keywords handling
#------------------------------------------------------------------------------     
   my ($key, $value) = split ':', $entry;   
      
   if ( $count ){#verification to see if keys already exists
      
      if (length($key) < 2 || length($value) < 2){

         say "\n\tError: invalid key or value!\n";
         next MAIN;
      
      }
      
      while (my $line = $file->chomp->getline()) {
      
         if ($line =~ m/^$key:/i){
            say "\n\tThe key '$key' already exists in $dirname! Try another.\n";
             
            next MAIN; 
         }
         
      }
           
      "$entry\n" >> io->file( $dir );
      
       
      say "\n\tThe key '$key' was stored with the value '$value' in $dirname!\n";
  }
  
  else{
     
      while (my $line = $file->chomp->getline()) {
      
         if ( $line =~ m/^\Q$key\E:/i ){
            
            my @lines = split ':', $line;
            say "Eco says: $lines[1]";#search and say
            next MAIN;
         }
      }
   
   say "\n\tError: key '$key' not found in $dirname!\n";
  }      
} 
#exit message
#------------------------------------------------------------------------------
say "Exiting...";
